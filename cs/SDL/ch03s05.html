<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Putting it all together</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec27"/>Putting it all together</h1></div></div></div><p>We can now put all of this knowledge together and implement as much as we can into our framework, with<a class="indexterm" id="id179"/> reusability in mind. We have quite a bit of work to do, so let's start with our abstract base class, <code class="literal">GameObject</code>. We are going to strip out anything SDL-specific so that we can reuse this class in other SDL projects if needed. Here is our stripped down <code class="literal">GameObject</code> abstract base class:</p><div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  virtual void draw()=0;
  virtual void update()=0;
  virtual void clean()=0;

protected:

  GameObject(const LoaderParams* pParams) {}
  virtual ~GameObject() {}
};</pre></div><p>The pure virtual functions have been created, forcing any derived classes to also declare and implement them. There is also now no <code class="literal">load</code> function; the reason for this is that we don't want to have to create a new <code class="literal">load</code> function for each new project. We can be pretty sure that we will need different values when loading our objects for different games. The approach we will take here is to create a new class called <code class="literal">LoaderParams</code> and pass that into the constructor of our objects.</p><p>
<code class="literal">LoaderParams</code> is simply a class that takes values into its constructor and sets them as member variables that can then<a class="indexterm" id="id180"/> be accessed to set the initial values of an object. While it may just seem that we are moving the parameters from the <code class="literal">load</code> function to somewhere else, it is a lot easier to just create a new <code class="literal">LoaderParams</code> class than to track down and alter the <code class="literal">load</code> function of all of our objects. </p><p>So here is our <code class="literal">LoaderParams</code> class:</p><div class="informalexample"><pre class="programlisting">class LoaderParams
{
public:

  LoaderParams(int x, int y, int width, int height, std::string 
  textureID) : m_x(x), m_y(y), m_width(width), m_height(height), 
  m_textureID(textureID)
  {

  }

  int getX() const { return m_x; }
  int getY() const { return m_y; }
  int getWidth() const { return m_width; }
  int getHeight() const { return m_height; }
  std::string getTextureID() const { return m_textureID; }

private:

  int m_x;
  int m_y;

  int m_width;
  int m_height;

  std::string m_textureID;
};</pre></div><p>This class holds any values we need when creating our object exactly the same way as our <code class="literal">load</code> function used to do.</p><p>We have also removed the <code class="literal">SDL_Renderer</code> parameter from the <code class="literal">draw</code> function. We will instead make our <code class="literal">Game</code> class a <a class="indexterm" id="id181"/>singleton, such as <code class="literal">TextureManager</code>. So, we can add the following to our <code class="literal">Game</code> class:</p><div class="informalexample"><pre class="programlisting">// create the public instance function
static Game* Instance()
{
  if(s_pInstance == 0)
  {
    s_pInstance = new Game();
    return s_pInstance;
  }

  return s_pInstance;
}
// make the constructor private
private:

  Game();
// create the s_pInstance member variable
  static Game* s_pInstance;

// create the typedef
  typedef Game TheGame;</pre></div><p>In the <code class="literal">Game.cpp</code>, we have to define our static instance:</p><div class="informalexample"><pre class="programlisting">Game* Game::s_pInstance = 0;</pre></div><p>Let's also create a function in the header file that will return our <code class="literal">SDL_Renderer</code> object:</p><div class="informalexample"><pre class="programlisting">SDL_Renderer* getRenderer() const { return m_pRenderer; }</pre></div><p>Now that <code class="literal">Game</code> is a singleton, we are going to use it differently in our <code class="literal">main.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char* argv[])
{
  std::cout &lt;&lt; "game init attempt...\n";
  if(TheGame::Instance()-&gt;init("Chapter 1", 100, 100, 640, 480, 
  false))
  {
    std::cout &lt;&lt; "game init success!\n";
    while(TheGame::Instance()-&gt;running())
    {
      TheGame::Instance()-&gt;handleEvents();
      TheGame::Instance()-&gt;update();
      TheGame::Instance()-&gt;render();

      SDL_Delay(10);
    }
  }
  else
  {
    std::cout &lt;&lt; "game init failure - " &lt;&lt; SDL_GetError() &lt;&lt; "\n";
    return -1;
  }

  std::cout &lt;&lt; "game closing...\n";
  TheGame::Instance()-&gt;clean();

  return 0;
}</pre></div><p>Now when we want to access the <code class="literal">m_pRenderer</code> value from <code class="literal">Game</code>, we can use the <a class="indexterm" id="id182"/>
<code class="literal">getRenderer</code> function.<a class="indexterm" id="id183"/> Now that <code class="literal">GameObject</code> is essentially empty, how do we achieve the code-sharing we originally had? We are going to derive a new generic class from <code class="literal">GameObject</code> and call it <code class="literal">SDLGameObject</code>:</p><div class="informalexample"><pre class="programlisting">class SDLGameObject : public GameObject
{
public:

  SDLGameObject(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();

protected:

  int m_x;
  int m_y;

  int m_width;
  int m_height;

  int m_currentRow;
  int m_currentFrame;

  std::string m_textureID;
};</pre></div><p>With this class we can create our reusable SDL code. First, we can use our new <code class="literal">LoaderParams</code> class to set <a class="indexterm" id="id184"/>our member variables:</p><div class="informalexample"><pre class="programlisting">SDLGameObject::SDLGameObject(const LoaderParams* pParams) : 
GameObject(pParams)
{
  m_x = pParams-&gt;getX();
  m_y = pParams-&gt;getY();
  m_width = pParams-&gt;getWidth();
  m_height = pParams-&gt;getHeight();
  m_textureID = pParams-&gt;getTextureID();

  m_currentRow = 1;
  m_currentFrame = 1;
}</pre></div><p>We can also use the same <a class="indexterm" id="id185"/>
<code class="literal">draw</code> function as before, making use of our singleton <code class="literal">Game</code> class to get the renderer we want:</p><div class="informalexample"><pre class="programlisting">void SDLGameObject::draw()
{
  TextureManager::Instance()-&gt;drawFrame(m_textureID, m_x, m_y, 
  m_width, m_height, m_currentRow, m_currentFrame, 
  TheGame::Instance()-&gt;getRenderer());
}</pre></div><p>
<code class="literal">Player</code> and <code class="literal">Enemy</code> can now inherit from <code class="literal">SDLGameObject</code>:</p><div class="informalexample"><pre class="programlisting">class Player : public SDLGameObject
{
public:

  Player(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();
};
// Enemy class
class Enemy : public SDLGameObject
{
public:

  Enemy(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();
};</pre></div><p>The <code class="literal">Player</code> class<a class="indexterm" id="id186"/> can be defined like so (the <code class="literal">Enemy</code> class is very similar):</p><div class="informalexample"><pre class="programlisting">Player::Player(const LoaderParams* pParams) : 
SDLGameObject(pParams)
{

}

void Player::draw()
{
  SDLGameObject::draw(); // we now use SDLGameObject
}

void Player::update()
{
  m_x -= 1;
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));
}

void Player::clean()
{
}</pre></div><p>Now that everything is in place, we can go ahead and create the objects in our <code class="literal">Game</code> class and see everything in action. We won't add the objects to the header file this time; we will use a shortcut and build our objects in one line in the <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">m_gameObjects.push_back(new Player(new LoaderParams(100, 100, 128, 82, "animate")));

m_gameObjects.push_back(new Enemy(new LoaderParams(300, 300, 128, 82, "animate")));</pre></div><p>Build the project. We<a class="indexterm" id="id187"/> now have everything in place to allow us to easily reuse our <code class="literal">Game</code> and <code class="literal">GameObject</code> classes.</p></div></body></html>