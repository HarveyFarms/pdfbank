<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Implementing menu states</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Implementing menu states"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Implementing menu states</h1></div></div></div><p>We will now move on to creating a<a class="indexterm" id="id298"/> simple menu state with visuals and mouse handling. We will use two new screenshots for our buttons, which are available with the source code downloads:</p><div class="mediaobject"><img alt="Implementing menu states" src="graphics/6821OT_05_01.jpg"/></div><p>The following screenshot shows the exit feature:</p><div class="mediaobject"><img alt="Implementing menu states" src="graphics/6821OT_05_02.jpg"/></div><p>These are essentially sprite sheets with the three states of our button. Let's create a new class for these buttons, <a class="indexterm" id="id299"/>which we will call <code class="literal">MenuButton</code>. Go ahead and create <code class="literal">MenuButton.h</code> and <code class="literal">MenuButton.cpp</code>. We will start with the header file:</p><div class="informalexample"><pre class="programlisting">class MenuButton : public SDLGameObject
{
public:

  MenuButton(const LoaderParams* pParams);

  virtual void draw();
  virtual void update();
  virtual void clean();
};</pre></div><p>By now this should look very familiar and it should feel straightforward to create new types. We will also define our button states as an enumerated type so that our code becomes more readable; put this in the header file under <code class="literal">private</code>:</p><div class="informalexample"><pre class="programlisting">enum button_state
{
  MOUSE_OUT = 0,
  MOUSE_OVER = 1,
  CLICKED = 2
};</pre></div><p>Open up the <code class="literal">MenuButton.cpp</code> file and we can start to flesh out our <code class="literal">MenuButton</code> class:</p><div class="informalexample"><pre class="programlisting">MenuButton::MenuButton(const LoaderParams* pParams) : SDLGameObject(pParams)
{
  m_currentFrame = MOUSE_OUT; // start at frame 0
}

void MenuButton::draw()
{
  SDLGameObject::draw(); // use the base class drawing
}

void MenuButton::update()
{
  Vector2D* pMousePos = TheInputHandler::Instance()
  -&gt;getMousePosition();

  if(pMousePos-&gt;getX() &lt; (m_position.getX() + m_width) 
  &amp;&amp; pMousePos-&gt;getX() &gt; m_position.getX()
  &amp;&amp; pMousePos-&gt;getY() &lt; (m_position.getY() + m_height) 
  &amp;&amp; pMousePos-&gt;getY() &gt; m_position.getY())
  {
    m_currentFrame = MOUSE_OVER;

    if(TheInputHandler::Instance()-&gt;getMouseButtonState(LEFT))
    {
      m_currentFrame = CLICKED;
    }
  }
  else
  {
    m_currentFrame = MOUSE_OUT;
  }
}

void MenuButton::clean()
{
  SDLGameObject::clean();
}</pre></div><p>The only thing really new in<a class="indexterm" id="id300"/> this class is the <code class="literal">update</code> function. Next, we will go through each step of this function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we get the coordinates of the mouse pointer and store them in a pointer to a <code class="literal">Vector2D</code> object:<div class="informalexample"><pre class="programlisting">Vector2D* pMousePos = TheInputHandler::Instance()-&gt;getMousePosition();</pre></div></li><li class="listitem" style="list-style-type: disc">Now, check whether the mouse is over the button or not. We do this by first checking whether the mouse position is less than the position of the right-hand side of the button (<span class="emphasis"><em>x position + width</em></span>). We then check if the mouse position is greater than the position of the left-hand side of the button (<span class="emphasis"><em>x position</em></span>). The y-position check is essentially the same with <span class="emphasis"><em>y position + height</em></span> and <span class="emphasis"><em>y position</em></span> for bottom and top respectively:<div class="informalexample"><pre class="programlisting">if(pMousePos-&gt;getX() &lt; (m_position.getX() + m_width) 
&amp;&amp; pMousePos-&gt;getX() &gt; m_position.getX()
&amp;&amp; pMousePos-&gt;getY() &lt; (m_position.getY() + m_height) 
&amp;&amp; pMousePos-&gt;getY() &gt; m_position.getY())</pre></div></li><li class="listitem" style="list-style-type: disc">If the previous check is true, we know that the mouse is hovering over our button; we set its frame to <code class="literal">MOUSE_OVER (1)</code>:<div class="informalexample"><pre class="programlisting">m_currentFrame = MOUSE_OVER;</pre></div></li><li class="listitem" style="list-style-type: disc">We can then check whether the mouse has been clicked; if it has, then we set the current frame to <code class="literal">CLICKED(2)</code>:<div class="informalexample"><pre class="programlisting">if(TheInputHandler::Instance()-&gt;getMouseButtonState(LEFT))
{
  m_currentFrame = CLICKED;
}</pre></div></li><li class="listitem" style="list-style-type: disc">If the check is not true,<a class="indexterm" id="id301"/> then we know the mouse is outside the button and we set the frame to <code class="literal">MOUSE_OUT (0)</code>:<div class="informalexample"><pre class="programlisting">else
{
  m_currentFrame = MOUSE_OUT;
}</pre></div></li></ul></div><p>We can now test out our reusable button class. Open up our previously created <code class="literal">MenuState.hand</code>, which we will implement for real. First, we are going to need a vector of <code class="literal">GameObject*</code> to store our menu items:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;GameObject*&gt; m_gameObjects;</pre></div><p>Inside the <code class="literal">MenuState.cpp</code> file, we can now start handling our menu items:</p><div class="informalexample"><pre class="programlisting">void MenuState::update()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}
void MenuState::render()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw();
  }
}</pre></div><p>The <code class="literal">onExit</code> and <code class="literal">onEnter</code> functions can be defined as follows:</p><div class="informalexample"><pre class="programlisting">bool MenuState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/button.png", 
  "playbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/exit.png", 
  "exitbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* button1 = new MenuButton(new LoaderParams(100, 100, 
  400, 100, "playbutton"));
  GameObject* button2 = new MenuButton(new LoaderParams(100, 300, 
  400, 100, "exitbutton"));

  m_gameObjects.push_back(button1);
  m_gameObjects.push_back(button2);

  std::cout &lt;&lt; "entering MenuState\n";
  return true;
}

bool MenuState::onExit()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;clean();
  }
  m_gameObjects.clear();
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("playbutton");
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("exitbutton");

  std::cout &lt;&lt; "exiting MenuState\n";
  return true;
}</pre></div><p>We use <code class="literal">TextureManager</code> to load our new images and then assign these textures to two buttons. The <code class="literal">TextureManager</code> class<a class="indexterm" id="id302"/> also has a new function called <code class="literal">clearFromTextureMap</code>, which takes the ID of the texture we want to remove; it is defined as follows:</p><div class="informalexample"><pre class="programlisting">void TextureManager::clearFromTextureMap(std::string id)
{
  m_textureMap.erase(id);
}</pre></div><p>This function enables us to clear only the textures from the current state, not the entire texture map. This is essential when we push states and then pop them, as we do not want the popped state to clear the original state's textures.</p><p>Everything else is essentially identical to how we handle objects in the <code class="literal">Game</code> class. Run the project and we will have buttons that react to mouse events. The window will look like the following screenshot (go ahead and test it out):</p><div class="mediaobject"><img alt="Implementing menu states" src="graphics/6821OT_05_03.jpg"/></div><div class="section" title="Function pointers and callback functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Function pointers and callback functions</h2></div></div></div><p>Our buttons react to rollovers<a class="indexterm" id="id303"/> and clicks but do not actually do anything yet. What we really want to achieve is the ability to create <code class="literal">MenuButton</code> and pass in the function we want it to call once it is clicked; we can achieve this through the use of function pointers. Function pointers do exactly as they say: they point to a function. We can use classic<a class="indexterm" id="id304"/> C style function pointers for the<a class="indexterm" id="id305"/> moment, as we are only going to use functions that do not take any parameters and always have a return type of <code class="literal">void</code> (therefore, we do not need to make them generic at this point). </p><p>The syntax for a function pointer is like this:</p><div class="informalexample"><pre class="programlisting">returnType (*functionName)(parameters);</pre></div><p>We declare our function pointer as a private member in <code class="literal">MenuButton.h</code> as follows:</p><div class="informalexample"><pre class="programlisting">void (*m_callback)();</pre></div><p>We also add a new member variable to handle clicking better:</p><div class="informalexample"><pre class="programlisting">bool m_bReleased;</pre></div><p>Now we can alter the constructor to allow us to pass in our function:</p><div class="informalexample"><pre class="programlisting">MenuButton(const LoaderParams* pParams, void (*callback)());</pre></div><p>In our <code class="literal">MenuButton.cpp</code> file, we can now alter the constructor and initialize our pointer with the initialization list:</p><div class="informalexample"><pre class="programlisting">MenuButton::MenuButton(const LoaderParams* pParams, void (*callback)() ) : SDLGameObject(pParams), m_callback(callback)</pre></div><p>The <code class="literal">update</code> function can now call this function:</p><div class="informalexample"><pre class="programlisting">void MenuButton::update()
{
  Vector2D* pMousePos = TheInputHandler::Instance()
  -&gt;getMousePosition();

  if(pMousePos-&gt;getX() &lt; (m_position.getX() + m_width) 
  &amp;&amp; pMousePos-&gt;getX() &gt; m_position.getX()
  &amp;&amp; pMousePos-&gt;getY() &lt; (m_position.getY() + m_height) 
  &amp;&amp; pMousePos-&gt;getY() &gt; m_position.getY())
  {
    if(TheInputHandler::Instance()-&gt;getMouseButtonState(LEFT) 
    &amp;&amp; m_bReleased)
    {
      m_currentFrame = CLICKED;

      m_callback(); // call our callback function

      m_bReleased = false;
    }
    else if(!TheInputHandler::Instance()
    -&gt;getMouseButtonState(LEFT))
    {
      m_bReleased = true;
      m_currentFrame = MOUSE_OVER;
    }
  }
  else
  {
    m_currentFrame = MOUSE_OUT;
  }
}</pre></div><p>Note that this <code class="literal">update</code> function<a class="indexterm" id="id306"/> now uses the <code class="literal">m_bReleased</code> value to ensure we release the mouse button before doing the<a class="indexterm" id="id307"/> callback again; this is how we want our clicking to behave.</p><p>In our <code class="literal">MenuState.h</code> object, we can declare some functions that we will pass into the constructors of our <code class="literal">MenuButton</code> objects:</p><div class="informalexample"><pre class="programlisting">private:
// call back functions for menu items
static void s_menuToPlay();
static void s_exitFromMenu();</pre></div><p>We have declared these functions as static; this is because our callback functionality will only support static functions. It is a little more complicated to handle regular member functions as function pointers, so we will avoid this and stick to static functions. We can define these functions in the <code class="literal">MenuState.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">void MenuState::s_menuToPlay()
{
  std::cout &lt;&lt; "Play button clicked\n";
}

void MenuState::s_exitFromMenu()
{
  std::cout &lt;&lt; "Exit button clicked\n";
}</pre></div><p>We can pass these functions into the constructors of our buttons:</p><div class="informalexample"><pre class="programlisting">GameObject* button1 = new MenuButton(new LoaderParams(100, 100, 400, 100, "playbutton"), s_menuToPlay);
GameObject* button2 = new MenuButton(new LoaderParams(100, 300, 400, 100, "exitbutton"), s_exitFromMenu);</pre></div><p>Test our project and you will see our functions printing to the console. We are now passing in the function we want our <a class="indexterm" id="id308"/>button to call once it is clicked; this functionality is great for our buttons. Let's test the exit button with some real functionality:</p><div class="informalexample"><pre class="programlisting">void MenuState::s_exitFromMenu()
{
  TheGame::Instance()-&gt;quit();
}</pre></div><p>Now clicking on our exit button will exit the game. The next step is to allow the <code class="literal">s_menuToPlay</code> function to move to <code class="literal">PlayState</code>. We first need to add a getter to the <code class="literal">Game.h</code> file to allow us to access the state machine:</p><div class="informalexample"><pre class="programlisting">GameStateMachine* getStateMachine(){ return m_pGameStateMachine; }</pre></div><p>We can now use this to change states in <code class="literal">MenuState</code>:</p><div class="informalexample"><pre class="programlisting">void MenuState::s_menuToPlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  PlayState());
}</pre></div><p>Go ahead and test; <code class="literal">PlayState</code> does not do anything yet, but our console output should show the movement between states.</p></div><div class="section" title="Implementing the temporary play state"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Implementing the temporary play state</h2></div></div></div><p>We have created <code class="literal">MenuState</code>; next, we need to create <code class="literal">PlayState</code> so that we can visually see the change in our states. For <code class="literal">PlayState</code> we will create a player object that uses our <code class="literal">helicopter.png</code> image and <a class="indexterm" id="id309"/>follows the mouse around. We will start with the <code class="literal">Player.cpp</code> file and add the code to make the <code class="literal">Player</code> object follow the mouse position:</p><div class="informalexample"><pre class="programlisting">void Player::handleInput()
{
  Vector2D* target = TheInputHandler::Instance()
  -&gt;getMousePosition();

  m_velocity = *target - m_position;

  m_velocity /= 50;
}</pre></div><p>First, we get the current mouse location; we can then get a vector that leads from the current position to the mouse position by subtracting the current position from the mouse position. We then divide the<a class="indexterm" id="id310"/> velocity by a scalar to slow us down a little and allow us to see our helicopter catch up to the mouse rather than stick to it. Our <code class="literal">PlayState.h</code> file will now need its own vector of <code class="literal">GameObject*</code>:</p><div class="informalexample"><pre class="programlisting">class GameObject;

class PlayState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const { return s_playID; }

private:

  static const std::string s_playID;

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>Finally, we must update the <code class="literal">PlayState.cpp</code> implementation file to use our <code class="literal">Player</code> object:</p><div class="informalexample"><pre class="programlisting">const std::string PlayState::s_playID = "PLAY";

void PlayState::update()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}

void PlayState::render()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw();
  }
}

bool PlayState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/helicopter.png", 
  "helicopter", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* player = new Player(new LoaderParams(100, 100, 128, 
  55, "helicopter");

  m_gameObjects.push_back(player);

  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}

bool PlayState::onExit()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;clean();
  }
  m_gameObjects.clear();
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("helicopter");

  std::cout &lt;&lt; "exiting PlayState\n";
  return true;
}</pre></div><p>This file is very similar to the<a class="indexterm" id="id311"/> <code class="literal">MenuState.cpp</code> file, but this time we are using a <code class="literal">Player</code> object rather than the two <code class="literal">MenuButton</code> objects. There is one adjustment to our <code class="literal">SDLGameObject.cpp</code> file that will make <code class="literal">PlayState</code> look even better; we are going to flip the image file depending on the velocity of the object:</p><div class="informalexample"><pre class="programlisting">void SDLGameObject::draw()
{
  if(m_velocity.getX() &gt; 0)
  {
    TextureManager::Instance()-&gt;drawFrame(m_textureID, 
    (Uint32)m_position.getX(), (Uint32)m_position.getY(),
    m_width, m_height, m_currentRow, m_currentFrame, 
    TheGame::Instance()-&gt;getRenderer(),SDL_FLIP_HORIZONTAL);
  }
  else
  {
    TextureManager::Instance()-&gt;drawFrame(m_textureID, 
    (Uint32)m_position.getX(), (Uint32)m_position.getY(),
    m_width, m_height, m_currentRow, m_currentFrame, 
    TheGame::Instance()-&gt;getRenderer());
  }
}</pre></div><p>We check whether<a class="indexterm" id="id312"/> the object's velocity is more than <code class="literal">0</code> (moving to the right-hand side) and flip the image accordingly. Run our game and you will now have the ability to move between <code class="literal">MenuState</code> and <code class="literal">PlayState</code> each with their own functionality and objects. The following screenshot shows our project so far:</p><div class="mediaobject"><img alt="Implementing the temporary play state" src="graphics/6821OT_05_04.jpg"/></div></div><div class="section" title="Pausing the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Pausing the game</h2></div></div></div><p>Another very important state<a class="indexterm" id="id313"/> for our games is the pause state. Once paused, the game could have all kinds of options. Our <code class="literal">PauseState</code> class will be very similar to the <code class="literal">MenuState</code>, but with different button visuals and callbacks. Here are our two new screenshots (again available in the source code download):</p><div class="mediaobject"><img alt="Pausing the game" src="graphics/6821OT_05_05.jpg"/></div><p>The following screenshot shows the resume functionality:</p><div class="mediaobject"><img alt="Pausing the game" src="graphics/6821OT_05_06.jpg"/></div><p>Let's start by<a class="indexterm" id="id314"/> creating our <code class="literal">PauseState.h</code> file in the project:</p><div class="informalexample"><pre class="programlisting">class GameObject;

class PauseState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const { return s_pauseID; }

private:

  static void s_pauseToMain();
  static void s_resumePlay();

  static const std::string s_pauseID;

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>Next, create our <code class="literal">PauseState.cpp</code> file<a class="indexterm" id="id315"/>:</p><div class="informalexample"><pre class="programlisting">const std::string PauseState::s_pauseID = "PAUSE";

void PauseState::s_pauseToMain()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  MenuState());
}

void PauseState::s_resumePlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;popState();
}

void PauseState::update()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}

void PauseState::render()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw();
  }
}

bool PauseState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/resume.png", 
  "resumebutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/main.png", 
  "mainbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* button1 = new MenuButton(new LoaderParams(200, 100, 
  200, 80, "mainbutton"), s_pauseToMain);
  GameObject* button2 = new MenuButton(new LoaderParams(200, 300, 
  200, 80, "resumebutton"), s_resumePlay);

  m_gameObjects.push_back(button1);
  m_gameObjects.push_back(button2);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}

bool PauseState::onExit()
{
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;clean();
  }
  m_gameObjects.clear();
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("resumebutton");
  TheTextureManager::Instance()
  -&gt;clearFromTextureMap("mainbutton");
  // reset the mouse button states to false
  TheInputHandler::Instance()-&gt;reset();

  std::cout &lt;&lt; "exiting PauseState\n";
  return true;
}</pre></div><p>In our <code class="literal">PlayState.cpp</code> file, we can<a class="indexterm" id="id316"/> now use our new <code class="literal">PauseState</code> class:</p><div class="informalexample"><pre class="programlisting">void PlayState::update()
{
  if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_ESCAPE))
  {
    TheGame::Instance()-&gt;getStateMachine()-&gt;pushState(new 
    PauseState());
  }

  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}</pre></div><p>This function listens for the <span class="emphasis"><em>Esc</em></span> key being pressed, and once it has been pressed, it then pushes a new <code class="literal">PauseState</code> class onto the state array in FSM. Remember that <code class="literal">pushState</code> does not remove the old state; it merely stops using it and uses the new state. Once we are done with the pushed state, we remove it from the state array and the game continues to use the previous state. We remove the <a class="indexterm" id="id317"/>pause state using the resume button's callback:</p><div class="informalexample"><pre class="programlisting">void PauseState::s_resumePlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;popState();
}</pre></div><p>The main menu button takes us back to the main menu and completely removes any other states:</p><div class="informalexample"><pre class="programlisting">void PauseState::s_pauseToMain()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  MenuState());
}</pre></div></div><div class="section" title="Creating the game over state"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Creating the game over state</h2></div></div></div><p>We are going to create<a class="indexterm" id="id318"/> one final state, <code class="literal">GameOverState</code>. To get to this state, we will use collision detection and a new <code class="literal">Enemy</code> object in the <code class="literal">PlayState</code> class<a class="indexterm" id="id319"/>. We will check whether the <code class="literal">Player</code> object has hit the <code class="literal">Enemy</code> object, and if so, we will change to our <code class="literal">GameOverState</code> class. Our Enemy object will use a new image <code class="literal">helicopter2.png</code>:</p><div class="mediaobject"><img alt="Creating the game over state" src="graphics/6821OT_05_07.jpg"/></div><p>We will make our <code class="literal">Enemy</code> object's helicopter move up and down the screen just to keep things interesting. In our <code class="literal">Enemy.cpp</code> file, we will add this functionality:</p><div class="informalexample"><pre class="programlisting">Enemy::Enemy(const LoaderParams* pParams) : SDLGameObject(pParams)
{
  m_velocity.setY(2);
  m_velocity.setX(0.001);
}

void Enemy::draw()
{
  SDLGameObject::draw();
}

void Enemy::update()
{
  m_currentFrame = int(((SDL_GetTicks() / 100) % m_numFrames));

  if(m_position.getY() &lt; 0)
  {
    m_velocity.setY(2);
  }
  else if(m_position.getY() &gt; 400)
  {
    m_velocity.setY(-2);
  }

  SDLGameObject::update();
}</pre></div><p>We can now add an <code class="literal">Enemy</code> object to our <code class="literal">PlayState</code> class:</p><div class="informalexample"><pre class="programlisting">bool PlayState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/helicopter.png", 
  "helicopter", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()
  -&gt;load("assets/helicopter2.png", "helicopter2", 
  TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }


  GameObject* player = new Player(new LoaderParams(500, 100, 128, 
  55, "helicopter"));
  GameObject* enemy = new Enemy(new LoaderParams(100, 100, 128, 
  55, "helicopter2"));

  m_gameObjects.push_back(player);
  m_gameObjects.push_back(enemy);

  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}</pre></div><p>Running the game will allow us to see our two helicopters:</p><div class="mediaobject"><img alt="Creating the game over state" src="graphics/6821OT_05_08.jpg"/></div><p>Before we cover collision detection, we are going to create our <code class="literal">GameOverState</code> class<a class="indexterm" id="id320"/>. We will be using two <a class="indexterm" id="id321"/>new images for this state, one for new <code class="literal">MenuButton</code> and one for a new type, which we will call <code class="literal">AnimatedGraphic</code>:</p><div class="mediaobject"><img alt="Creating the game over state" src="graphics/6821OT_05_09.jpg"/></div><p>The following screenshot shows the game over functionality:</p><div class="mediaobject"><img alt="Creating the game over state" src="graphics/6821OT_05_10.jpg"/></div><p>
<code class="literal">AnimatedGraphic</code> is<a class="indexterm" id="id322"/> very similar to other types, so I will not go into too much detail here; however, what is important is the added value in the constructor that controls the speed of the animation, which sets the private member variable <code class="literal">m_animSpeed</code>:</p><div class="informalexample"><pre class="programlisting">AnimatedGraphic::AnimatedGraphic(const LoaderParams* pParams, int animSpeed) : SDLGameObject(pParams), m_animSpeed(animSpeed)
{

}</pre></div><p>The <code class="literal">update</code> function will use this value to set the speed of the animation:</p><div class="informalexample"><pre class="programlisting">void AnimatedGraphic::update()
{
  m_currentFrame = int(((SDL_GetTicks() / (1000 / m_animSpeed)) % 
  m_numFrames));
}</pre></div><p>Now that we have the <code class="literal">AnimatedGraphic</code> class<a class="indexterm" id="id323"/>, we can implement our <code class="literal">GameOverState</code> class. Create <code class="literal">GameOverState.h</code> and <code class="literal">GameOverState.cpp</code> in our project; the header file we will create should look very familiar, as given in the following code:</p><div class="informalexample"><pre class="programlisting">class GameObject;

class GameOverState : public GameState
{
public:

  virtual void update();
  virtual void render();

  virtual bool onEnter();
  virtual bool onExit();

  virtual std::string getStateID() const {return s_gameOverID;}

private:

  static void s_gameOverToMain();
  static void s_restartPlay();

  static const std::string s_gameOverID;

  std::vector&lt;GameObject*&gt; m_gameObjects;
};</pre></div><p>Our implementation file is also very similar to other files already covered, so again I will only cover the parts that are different. First, we define our static variables and functions:</p><div class="informalexample"><pre class="programlisting">const std::string GameOverState::s_gameOverID = "GAMEOVER";

void GameOverState::s_gameOverToMain()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  MenuState());
}

void GameOverState::s_restartPlay()
{
  TheGame::Instance()-&gt;getStateMachine()-&gt;changeState(new 
  PlayState());
}</pre></div><p>The <code class="literal">onEnter</code> function<a class="indexterm" id="id324"/> will create three new<a class="indexterm" id="id325"/> objects along with their textures:</p><div class="informalexample"><pre class="programlisting">bool GameOverState::onEnter()
{
  if(!TheTextureManager::Instance()-&gt;load("assets/gameover.png", 
  "gameovertext", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/main.png", 
  "mainbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  if(!TheTextureManager::Instance()-&gt;load("assets/restart.png", 
  "restartbutton", TheGame::Instance()-&gt;getRenderer()))
  {
    return false;
  }

  GameObject* gameOverText = new AnimatedGraphic(new 
  LoaderParams(200, 100, 190, 30, "gameovertext", 2), 2);
  GameObject* button1 = new MenuButton(new LoaderParams(200, 200, 
  200, 80, "mainbutton"), s_gameOverToMain);
  GameObject* button2 = new MenuButton(new LoaderParams(200, 300, 
  200, 80, "restartbutton"), s_restartPlay);

  m_gameObjects.push_back(gameOverText);
  m_gameObjects.push_back(button1);
  m_gameObjects.push_back(button2);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}</pre></div><p>That is pretty much it for our<a class="indexterm" id="id326"/> <code class="literal">GameOverState</code> class<a class="indexterm" id="id327"/>, but we must now create a condition that creates this state. Move to our <code class="literal">PlayState.h</code> file and we will create a new function to allow us to check for collisions:</p><div class="informalexample"><pre class="programlisting">bool checkCollision(SDLGameObject* p1, SDLGameObject* p2);</pre></div><p>We will define this function in <code class="literal">PlayState.cpp</code>:</p><div class="informalexample"><pre class="programlisting">bool PlayState::checkCollision(SDLGameObject* p1, SDLGameObject* 
p2)
{
  int leftA, leftB;
  int rightA, rightB;
  int topA, topB;
  int bottomA, bottomB;

  leftA = p1-&gt;getPosition().getX();
  rightA = p1-&gt;getPosition().getX() + p1-&gt;getWidth();
  topA = p1-&gt;getPosition().getY();
  bottomA = p1-&gt;getPosition().getY() + p1-&gt;getHeight();

  //Calculate the sides of rect B
  leftB = p2-&gt;getPosition().getX();
  rightB = p2-&gt;getPosition().getX() + p2-&gt;getWidth();
  topB = p2-&gt;getPosition().getY();
  bottomB = p2-&gt;getPosition().getY() + p2-&gt;getHeight();

  //If any of the sides from A are outside of B
  if( bottomA &lt;= topB ){return false;} 
  if( topA &gt;= bottomB ){return false; }
  if( rightA &lt;= leftB ){return false; }
  if( leftA &gt;= rightB ){return false;}

  return true;
}</pre></div><p>This function checks for collisions between two <code class="literal">SDLGameObject</code> types. For the function to work, we need to add three new functions to our <code class="literal">SDLGameObject</code> class:</p><div class="informalexample"><pre class="programlisting">Vector2D&amp; getPosition() { return m_position; }
int getWidth() { return m_width; }
int getHeight() { return m_height; }</pre></div><p>The next chapter will deal with how<a class="indexterm" id="id328"/> this function works, but for now, it is enough to know that it does. Our <code class="literal">PlayState</code> class will now utilize this collision detection in its <a class="indexterm" id="id329"/>
<code class="literal">update</code> function:</p><div class="informalexample"><pre class="programlisting">void PlayState::update()
{
  if(TheInputHandler::Instance()-&gt;isKeyDown(SDL_SCANCODE_ESCAPE))
  {
    TheGame::Instance()-&gt;getStateMachine()-&gt;pushState(new 
    PauseState());
  }

  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }

  if(checkCollision(dynamic_cast&lt;SDLGameObject*&gt;
  (m_gameObjects[0]), dynamic_cast&lt;SDLGameObject*&gt;
  (m_gameObjects[1])))
  {
    TheGame::Instance()-&gt;getStateMachine()-&gt;pushState(new 
    GameOverState());
  }
}</pre></div><p>We have to use a <code class="literal">dynamic_cast</code> object to cast our<a class="indexterm" id="id330"/> <code class="literal">GameObject*</code> class to an <code class="literal">SDLGameObject*</code> class. If <code class="literal">checkCollision</code> returns <code class="literal">true</code>, then we add the <code class="literal">GameOverState</code> class. The <a class="indexterm" id="id331"/>following screenshot shows the <code class="literal">GameOver</code> state:</p><div class="mediaobject"><img alt="Creating the game over state" src="graphics/6821OT_05_11.jpg"/></div></div></div></body></html>