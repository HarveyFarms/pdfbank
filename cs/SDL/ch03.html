<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 3. Working with Game Objects</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="chapter" title="Chapter 3. Working with Game Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Game Objects</h1></div></div></div><p>All games have objects, for example, players, enemies, <span class="strong"><strong>non-player character</strong></span> (<span class="strong"><strong>NPC</strong></span>), traps, bullets, and doors. Keeping track of all these objects and how they<a class="indexterm" id="id154"/> interact with each other is a big task and one that we would like to make as simple as possible. Our game could become unwieldy and difficult to update if we do not have a solid implementation. So what can we do to make our task easier? We can start by really trying to leverage the power of <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>). We will cover the following in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using inheritance</li><li class="listitem" style="list-style-type: disc">Implementing polymorphism</li><li class="listitem" style="list-style-type: disc">Using abstract base classes</li><li class="listitem" style="list-style-type: disc">Effective inheritance design</li></ul></div><div class="section" title="Using inheritance"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec23"/>Using inheritance</h1></div></div></div><p>The first powerful feature of OOP we will look at is inheritance. This feature can help us enormously when developing our reusable framework. Through the use of inheritance, we can share common functionality between similar classes and also create subtypes from existing types. We will <a class="indexterm" id="id155"/>not go into too much detail about inheritance itself but instead we will start to think about how we will apply it to our framework.</p><p>As mentioned earlier, all games have objects of various types. In most cases, these objects will have a lot of the same data and require a lot of the same basic functions. Let's look at some examples of this<a class="indexterm" id="id156"/> common functionality:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Almost all of our objects will be drawn to the screen, thus requiring a <code class="literal">draw</code> function</li><li class="listitem" style="list-style-type: disc">If our objects are to be drawn, they will need a location to draw to, that is, x and y position variables</li><li class="listitem" style="list-style-type: disc">We don't want static objects all the time, so we will need an <code class="literal">update</code> function</li><li class="listitem" style="list-style-type: disc">Objects will be responsible for cleaning up after themselves; a function that deals with this will be important</li></ul></div><p>This is a good starting <a class="indexterm" id="id157"/>point for our first game object class, so let's go ahead and create it. Add a new class to the project called <code class="literal">GameObject</code> and we can begin:</p><div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  void draw() { std::cout &lt;&lt; "draw game object"; }
  void update() { std::cout &lt;&lt; "update game object"; }
  void clean() { std::cout &lt;&lt; "clean game object"; }

protected:

  int m_x;
  int m_y;
};</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>The public, protected, and private keywords are very important. Public functions and data are accessible from anywhere. Protected status restricts access to only those classes derived from it. Private members are only available to that class, not even its derived classes.</p></div></div><p>So, there we have our first game object class. Now let's inherit from it and create a class called <code class="literal">Player</code>:</p><div class="informalexample"><pre class="programlisting">class Player : public GameObject // inherit from GameObject
{
public:

  void draw()
  {
    GameObject::draw();
    std::cout &lt;&lt; "draw player";
  }
  void update()
  {
    std::cout &lt;&lt; "update player";
    m_x = 10;
    m_y = 20;
  }
  void clean()
  {
    GameObject::clean();
    std::cout &lt;&lt; "clean player";
  }
};</pre></div><p>What we have achieved is the ability to reuse the code and data that we originally had in <code class="literal">GameObject</code> and apply<a class="indexterm" id="id158"/> it to our new <code class="literal">Player</code> class. As you can see, a derived class can override the functionality of a parent class:</p><div class="informalexample"><pre class="programlisting">void update()
{
  std::cout &lt;&lt; "update player";
  m_x = 10;
  m_y = 20;
}</pre></div><p>Or it can even use the functionality of the parent class, while also having its own additional functionality on top:</p><div class="informalexample"><pre class="programlisting">void draw()
{
  GameObject::draw();
  std::cout &lt;&lt; "draw player";
}</pre></div><p>Here we call the <code class="literal">draw</code> function from <code class="literal">GameObject</code> and then define some player-specific functionality.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The <code class="literal">::</code> operator is called the scope resolution operator and it is used to identify the specific place that some data or function resides.</p></div></div><p>Okay, so far our classes do not do much, so let's add some of our SDL functionality. We will add some drawing code to the <a class="indexterm" id="id159"/>
<code class="literal">GameObject</code> class and then reuse it within our <code class="literal">Player</code> class. First we will update our <code class="literal">GameObject</code> header file with some new values and functions to allow us to use our existing SDL code:</p><div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  void load(int x, int y, int width, int height, std::string 
  textureID);
  void draw(SDL_Renderer* pRenderer);
  void update();
  void clean();

protected:

  std::string m_textureID;

  int m_currentFrame;
  int m_currentRow;

  int m_x;
  int m_y;

  int m_width;
  int m_height;
};</pre></div><p>We now have some new<a class="indexterm" id="id160"/> member variables that will be set in the new <code class="literal">load</code> function. We are also passing in the <code class="literal">SDL_Renderer</code> object we want to use in our <code class="literal">draw</code> function. Let's define these functions in an implementation file and create <code class="literal">GameObject.cpp</code>:</p><p>First define our new <code class="literal">load</code> function:</p><div class="informalexample"><pre class="programlisting">void GameObject::load(int x, int y, int width, int height, std::string textureID)
{
  m_x = x;
  m_y = y;
  m_width = width;
  m_height = height;
  m_textureID = textureID;

  m_currentRow = 1;
  m_currentFrame = 1;
}</pre></div><p>Here we are setting all of the values we declared in the header file. We will just use a start value of <code class="literal">1</code> for our <code class="literal">m_currentRow</code> and <code class="literal">m_currentFrame</code> values. Now we can create our <code class="literal">draw</code> function that will make use of these values:</p><div class="informalexample"><pre class="programlisting">void GameObject::draw(SDL_Renderer* pRenderer)
{
  TextureManager::Instance()-&gt;drawFrame(m_textureID, m_x, m_y, 
  m_width, m_height, m_currentRow, m_currentFrame, pRenderer);
}</pre></div><p>We grab the texture <a class="indexterm" id="id161"/>we want from <code class="literal">TextureManager</code> using <code class="literal">m_textureID</code> and draw it according to our set values. Finally we can just put something in our <code class="literal">update</code> function that we can override in the <code class="literal">Player</code> class:</p><div class="informalexample"><pre class="programlisting">void GameObject::update()
{
  m_x += 1;
}</pre></div><p>Our <code class="literal">GameObject</code> class is complete for now. We can now alter the <code class="literal">Player</code> header file to reflect our changes:</p><div class="informalexample"><pre class="programlisting">#include "GameObject.h"

class Player : public GameObject
{
public:

  void load(int x, int y, int width, int height, std::string 
  textureID);
  void draw(SDL_Renderer* pRenderer);
  void update();
  void clean();
};</pre></div><p>We can now move on to defining these functions in an implementation file. Create <code class="literal">Player.cpp</code> and we'll walk through the functions. First we will start with the <code class="literal">load</code> function:</p><div class="informalexample"><pre class="programlisting">void Player::load(int x, int y, int width, int height, string textureID)
{
  GameObject::load(x, y, width, height, textureID);
}</pre></div><p>Here we can use our <code class="literal">GameObject::load</code> function. And the same applies to our <code class="literal">draw</code> function:</p><div class="informalexample"><pre class="programlisting">void Player::draw(SDL_Renderer* pRenderer)
{
  GameObject::draw(pRenderer);
}</pre></div><p>And let's<a class="indexterm" id="id162"/> override the <code class="literal">update</code> function with something different; let's animate this one and move it in the opposite direction:</p><div class="informalexample"><pre class="programlisting">void Player::update()
{
  m_x -= 1;
}</pre></div><p>We are all set; we can create these objects in the <code class="literal">Game</code> header file:</p><div class="informalexample"><pre class="programlisting">GameObject m_go;
Player m_player;</pre></div><p>Then load them in the <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">m_go.load(100, 100, 128, 82, "animate");
m_player.load(300, 300, 128, 82, "animate");</pre></div><p>They will then need to be added to the <code class="literal">render</code> and <code class="literal">update</code> functions:</p><div class="informalexample"><pre class="programlisting">void Game::render()
{

  SDL_RenderClear(m_pRenderer); // clear to the draw colour

  m_go.draw(m_pRenderer);
  m_player.draw(m_pRenderer);

  SDL_RenderPresent(m_pRenderer); // draw to the screen

}

void Game::update()
{
  m_go.update();
  m_player.update();
}</pre></div><p>We have one more thing to add to make this run correctly. We need to cap our frame rate slightly; if we do not, then our objects will move far too fast. We will go into more detail about this in a later<a class="indexterm" id="id163"/> chapter, but for now we can just put a delay in our main loop. So, back in <code class="literal">main.cpp</code>, we can add this line:</p><div class="informalexample"><pre class="programlisting">while(g_game-&gt;running())
{
  g_game-&gt;handleEvents();
  g_game-&gt;update();
  g_game-&gt;render();

  SDL_Delay(10); // add the delay
}</pre></div><p>Now build and run to see our two separate objects:</p><div class="mediaobject"><img alt="Using inheritance" src="graphics/6821OT_03_01.jpg"/></div><p>Our <code class="literal">Player</code> class was extremely easy to write, as we had already written some of the code in our <code class="literal">GameObject</code> class, along with the needed variables. You may have noticed, however, that we were copying code into a lot of places in the <code class="literal">Game</code> class. It requires a lot of steps to create and add a new object to the game. This is not ideal, as it would be easy to miss a step and also it will get extremely hard to manage and maintain when a game goes beyond having two or three different objects.</p><p>What we really <a class="indexterm" id="id164"/>want is for our <code class="literal">Game</code> class not to need to care about different types; then we could loop through all of our game objects in one go, with separate loops for each of their functions.</p></div></div></body></html>