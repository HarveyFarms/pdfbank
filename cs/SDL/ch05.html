<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 5. Handling Game States</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="chapter" title="Chapter 5. Handling Game States"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Handling Game States</h1></div></div></div><p>When we first start up a game, we expect to see a splash screen showing any branding for publishers and developers, followed by a loading screen as the game does its initial setup. After this, we are usually faced with a menu screen; here, we can change settings and start the game. Starting the game leads us to another loading screen, possibly followed by a cut scene, and finally, we are in the game. When we are in the game, we can pause our play (allowing us to change any settings), exit the game, restart the level, and so on. If we fail the level, we are shown either an animation or a game over screen depending on how the game is set up. All of these different sections of a game are called <a class="indexterm" id="id274"/>
<span class="emphasis"><em>Game States</em></span>. It is very important that we make the transition between these states as easy as possible.</p><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two different ways of handling states, starting with a really simple implementation and gradually building our framework implementation</li><li class="listitem" style="list-style-type: disc">Implementing <span class="strong"><strong>Finite State Machines</strong></span> (<span class="strong"><strong>FSM</strong></span>)</li><li class="listitem" style="list-style-type: disc">Adding states to the overall framework</li></ul></div><div class="section" title="A simple way for switching states"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>A simple way for switching states</h1></div></div></div><p>One of the simplest ways to handle <a class="indexterm" id="id275"/>states is to load everything we want at the game's initialization stage, but only draw and update the objects specific to each state. Let's look at an example of how this could work. First, we can define a set of states we are going to use:</p><div class="informalexample"><pre class="programlisting">enum game_states
{
  MENU = 0,
  PLAY = 1,
  GAMEOVER = 2
};</pre></div><p>We can then use the <code class="literal">Game::init</code> function to create the objects:</p><div class="informalexample"><pre class="programlisting">// create menu objects
m_pMenuObj1 = new MenuObject();
m_pMenuObj1 = new MenuObject();

// create play objects
m_pPlayer = new Player();
m_pEnemy = new Enemy();

// create game over objects…</pre></div><p>Then, set our initial state:</p><div class="informalexample"><pre class="programlisting">m_currentGameState = MENU;</pre></div><p>Next, we can change our <code class="literal">update</code> function<a class="indexterm" id="id276"/> to only use the things we want when in a specific state:</p><div class="informalexample"><pre class="programlisting">void Game::update()
{
  switch(m_currentGameState)
  {
    case MENU:
      m_menuObj1-&gt;update();
      m_menuObj2-&gt;update();
      break;

    case PLAY:
      m_pPlayer-&gt;update();
      m_pEnemy-&gt;update();

    case GAMEOVER:
      // do game over stuff…
  }
}</pre></div><p>The <code class="literal">render</code> function<a class="indexterm" id="id277"/> would do something similar. These functions could of course still loop through arrays and use polymorphism as we originally had done, but on a state-by-state basis. Changing states is as simple as changing the value of the <code class="literal">m_currentGameState</code> variable.</p><p>If you can see issues with this method, then it is very encouraging that you are starting to think in an object-oriented way. This way of updating states would be a bit of a nightmare to maintain and the scope for error is quite large. There are too many areas that need to be updated and <a class="indexterm" id="id278"/>changed to make this a viable solution for any game larger than a simple arcade game.</p></div></div></body></html>