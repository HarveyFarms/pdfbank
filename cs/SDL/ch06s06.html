<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Loading other states from an XML file</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Loading other states from an XML file"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Loading other states from an XML file</h1></div></div></div><p>Our <a class="indexterm" id="id374"/>
<code class="literal">MainMenuState</code> class now loads from an XML file. We need to make our other states do the same. We<a class="indexterm" id="id375"/> will only cover the code that has changed, so assume that everything else has remained the same when following through this section.</p><div class="section" title="Loading the play state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Loading the play state</h2></div></div></div><p>We will start<a class="indexterm" id="id376"/> with <a class="indexterm" id="id377"/>
<code class="literal">PlayState.cpp</code> and its <code class="literal">onEnter</code> function.</p><div class="informalexample"><pre class="programlisting">bool PlayState::onEnter()
{
  // parse the state
  StateParser stateParser;
  stateParser.parseState("test.xml", s_playID, &amp;m_gameObjects, 
  &amp;m_textureIDList);

  std::cout &lt;&lt; "entering PlayState\n";
  return true;
}</pre></div><p>We must also add the new texture clearing code that we had in <code class="literal">MainMenuState</code> to the <code class="literal">onExit</code> function.</p><div class="informalexample"><pre class="programlisting">// clear the texture manager
for(int i = 0; i &lt; m_textureIDList.size(); i++)
{
  TheTextureManager::Instance()-&gt;
  clearFromTextureMap(m_textureIDList[i]);
}</pre></div><p>These are the only alterations that we will need to do here but we must also update our XML file to have something to load in <code class="literal">PlayState</code>.</p><div class="informalexample"><pre class="programlisting">&lt;PLAY&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="helicopter.png" ID="helicopter"/&gt;
  &lt;texture filename="helicopter2.png" ID="helicopter2"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="Player" x="500" y="100" width="128" height="55" 
  textureID="helicopter" numFrames="4"/&gt;
  &lt;object type="Enemy" x="100" y="100" width="128" height="55" 
  textureID="helicopter2" numFrames="4"/&gt;
&lt;/OBJECTS&gt;
&lt;/PLAY&gt;</pre></div><p>Our <code class="literal">Enemy</code> object <a class="indexterm" id="id378"/>will now need to set its initial velocity in its load function rather than the constructor, otherwise the <code class="literal">load</code> function would override it.</p><div class="informalexample"><pre class="programlisting">void Enemy::load(const LoaderParams *pParams)
{
  SDLGameObject::load(pParams);
  m_velocity.setY(2);
}</pre></div><p>Finally we must<a class="indexterm" id="id379"/> register these objects with the factory. We can do this in the <code class="literal">Game::init</code> function just like the <code class="literal">MenuButton</code> object.</p><div class="informalexample"><pre class="programlisting">TheGameObjectFactory::Instance()-&gt;registerType("Player", new PlayerCreator());
TheGameObjectFactory::Instance()-&gt;registerType("Enemy", new EnemyCreator());</pre></div></div><div class="section" title="Loading the pause state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Loading the pause state</h2></div></div></div><p>Our <code class="literal">PauseState</code> class<a class="indexterm" id="id380"/> must now inherit from <code class="literal">MenuState</code> as we want it to contain callbacks. We must update the <code class="literal">PauseState.h</code> file to first inherit <a class="indexterm" id="id381"/>from <code class="literal">MenuState</code>.</p><div class="informalexample"><pre class="programlisting">class PauseState : public MenuState</pre></div><p>We must also declare the <code class="literal">setCallbacks</code> function.</p><div class="informalexample"><pre class="programlisting">virtual void setCallbacks(const std::vector&lt;Callback&gt;&amp; callbacks);</pre></div><p>Now we must update the <code class="literal">PauseState.cpp</code> file, starting with the <code class="literal">onEnter</code> function.</p><div class="informalexample"><pre class="programlisting">bool PauseState::onEnter()
{
  StateParser stateParser;
  stateParser.parseState("test.xml", s_pauseID, &amp;m_gameObjects, 
  &amp;m_textureIDList);

  m_callbacks.push_back(0);
  m_callbacks.push_back(s_pauseToMain);
  m_callbacks.push_back(s_resumePlay);

  setCallbacks(m_callbacks);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}</pre></div><p>The <code class="literal">setCallbacks</code> function <a class="indexterm" id="id382"/>is exactly like <code class="literal">MainMenuState</code>.</p><div class="informalexample"><pre class="programlisting">void PauseState::setCallbacks(const std::vector&lt;Callback&gt;&amp; 
callbacks)
{
  // go through the game objects
  for(int i = 0; i &lt; m_gameObjects.size(); i++)
  {
    // if they are of type MenuButton then assign a callback based 
    on the id passed in from the file
    if(dynamic_cast&lt;MenuButton*&gt;(m_gameObjects[i]))
    {
      MenuButton* pButton = 
      dynamic_cast&lt;MenuButton*&gt;(m_gameObjects[i]);
      pButton-&gt;setCallback(callbacks[pButton-&gt;getCallbackID()]);
    }
  }
}</pre></div><p>Finally <a class="indexterm" id="id383"/>we must <a class="indexterm" id="id384"/>add the texture clearing code to <code class="literal">onExit</code>.</p><div class="informalexample"><pre class="programlisting">// clear the texture manager
for(int i = 0; i &lt; m_textureIDList.size(); i++)
{
  TheTextureManager::Instance()-&gt;
  clearFromTextureMap(m_textureIDList[i]);
}</pre></div><p>And then update our XML file to include this state.</p><div class="informalexample"><pre class="programlisting">&lt;PAUSE&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="resume.png" ID="resumebutton"/&gt;
  &lt;texture filename="main.png" ID="mainbutton"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="MenuButton" x="200" y="100" width="200" 
  height="80" textureID="mainbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="200" y="300" width="200" 
  height="80" textureID="resumebutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;
&lt;/PAUSE&gt;</pre></div></div><div class="section" title="Loading the game over state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Loading the game over state</h2></div></div></div><p>Our final state is <code class="literal">GameOverState</code>. Again this will be very similar to other states and we will only cover <a class="indexterm" id="id385"/>what has changed. Since we want <code class="literal">GameOverState</code> to handle callbacks it will now inherit from <code class="literal">MenuState</code>.</p><div class="informalexample"><pre class="programlisting">class GameOverState : public MenuState</pre></div><p>We will then declare<a class="indexterm" id="id386"/> the <code class="literal">setCallbacks</code> function.</p><div class="informalexample"><pre class="programlisting">virtual void setCallbacks(const std::vector&lt;Callback&gt;&amp; callbacks);</pre></div><p>The <code class="literal">onEnter</code> function should be looking very familiar now.</p><div class="informalexample"><pre class="programlisting">bool GameOverState::onEnter()
{
  // parse the state
  StateParser stateParser;
  stateParser.parseState("test.xml", s_gameOverID, &amp;m_gameObjects, 
  &amp;m_textureIDList);
  m_callbacks.push_back(0);
  m_callbacks.push_back(s_gameOverToMain);
  m_callbacks.push_back(s_restartPlay);

  // set the callbacks for menu items
  setCallbacks(m_callbacks);

  std::cout &lt;&lt; "entering PauseState\n";
  return true;
}</pre></div><p>The texture clearing method is the same as in the previous states, so we will leave you to implement that yourself. In fact <code class="literal">onExit</code> is looking so similar between states that it would be a good idea to make a generic implementation for it in <code class="literal">GameState</code> and just use that; again we will leave that to you.</p><p>You may have noticed the similarity between the <code class="literal">onEnter</code> functions<a class="indexterm" id="id387"/>. It would be great to have a default <code class="literal">onEnter</code> implementation but, unfortunately, due to the need to specify different callback<a class="indexterm" id="id388"/> functions, our callback implementation will not allow this and this is one of its main flaws.</p><p>Our <a class="indexterm" id="id389"/>
<code class="literal">AnimatedGraphic</code> class will now need to grab the <code class="literal">animSpeed</code> value from <code class="literal">LoaderParams</code> in its <code class="literal">load</code> function<a class="indexterm" id="id390"/>.</p><div class="informalexample"><pre class="programlisting">void AnimatedGraphic::load(const LoaderParams *pParams)
{
  SDLGameObject::load(pParams);
  m_animSpeed = pParams-&gt;getAnimSpeed();
}</pre></div><p>We will also have to register this type with <code class="literal">GameObjectFactory</code>.</p><div class="informalexample"><pre class="programlisting">TheGameObjectFactory::Instance()-&gt;registerType("AnimatedGraphic", new AnimatedGraphicCreator());</pre></div><p>And finally <a class="indexterm" id="id391"/>we can update the XML file to include this state:</p><div class="informalexample"><pre class="programlisting">&lt;GAMEOVER&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="gameover.png" ID="gameovertext"/&gt;
  &lt;texture filename="main.png" ID="mainbutton"/&gt;
  &lt;texture filename="restart.png" ID="restartbutton"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="AnimatedGraphic" x="200" y="100" width="190" 
  height="30" textureID="gameovertext" numFrames="2" 
  animSpeed="2"/&gt;
  &lt;object type="MenuButton" x="200" y="200" width="200" 
  height="80" textureID="mainbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="200" y="300" width="200" 
  height="80" textureID="restartbutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;
&lt;/GAMEOVER&gt;</pre></div><p>We now have all of our states loading from the XML file and one of the biggest benefits of this is that you do not have to recompile the game when you change a value. Go ahead and change the XML file to move positions or even use different textures for objects; if the XML is saved then you can just run the game again and it will use the new values. This is a huge time saver for us and gives us complete control over a state without the need to recompile our game.</p></div></div></body></html>