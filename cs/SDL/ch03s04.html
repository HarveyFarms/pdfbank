<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Should we always use inheritance?</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Should we always use inheritance?"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec26"/>Should we always use inheritance?</h1></div></div></div><p>Inheritance and polymorphism are both very useful and really show off the power of object-oriented programming. However, in some circumstances, inheritance can cause more problems than it<a class="indexterm" id="id174"/> solves, and therefore, we should bear in mind a few rules of thumb when deciding whether or not to use it.</p><div class="section" title="Could the same thing be achieved with a simpler solution?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl3sec03"/>Could the same thing be achieved with a simpler solution?</h2></div></div></div><p>Let's say we want to make a more powerful <code class="literal">Enemy</code> object; it will have the same behavior a regular <code class="literal">Enemy</code> object <a class="indexterm" id="id175"/>will have but with more health. One possible solution would be to derive a new class <code class="literal">PowerEnemy</code> from <code class="literal">Enemy</code> and give it double health. In this solution the new class will seem extremely sparse; it will use the functionality from <code class="literal">Enemy</code> but with one different value. An easier solution would be to have a way to set the health of an <code class="literal">Enemy</code> class, whether through an accessor or in the constructor. Inheritance isn't needed at all.</p></div><div class="section" title="Derived classes should model the &quot;is a&quot; relationship"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl3sec04"/>Derived classes should model the "is a" relationship</h2></div></div></div><p>When deriving a class, it is <a class="indexterm" id="id176"/>a good idea for it to model the "is a" relationship. This means that the derived class should also be of the same type as the parent class. For example, deriving a <code class="literal">Player2</code> class from <code class="literal">Player</code> would fit the model, as <code class="literal">Player2</code> "is a" <code class="literal">Player</code>. But let's say, for example, we have a <code class="literal">Jetpack</code> class and we derive <code class="literal">Player</code> from this class to give it access to all the functionality that a <code class="literal">Jetpack</code> class has. This would not model the "is a" relationship, as a <code class="literal">Player</code> class is not a <code class="literal">Jetpack</code> class. It makes a lot more sense to say a <code class="literal">Player</code> class has a <code class="literal">Jetpack</code> class, and therefore, a <code class="literal">Player</code> class<a class="indexterm" id="id177"/> should have a member variable of type <code class="literal">Jetpack</code> with no inheritance; this is known as containment.</p></div><div class="section" title="Possible performance penalties"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl3sec05"/>Possible performance penalties</h2></div></div></div><p>On platforms such as PC and Mac, the performance penalties of using inheritance and virtual functions are negligible. <a class="indexterm" id="id178"/>However, if you are developing for less powerful devices such as handheld consoles, phones, or embedded systems, this is something that you should take into account. If your core loop involves calling a virtual function many times per second, the performance penalties can add up.</p></div></div></body></html>