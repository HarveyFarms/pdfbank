<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dealing with collisions</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Dealing with collisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Dealing with collisions</h1></div></div></div><p>With so many bullets flying around and having the <code class="literal">Enemy</code> objects to check collisions against, it is important that there be a separate class that does this collision checking for us. This way we<a class="indexterm" id="id500"/> know where to look if we decide we want to implement a new way of checking for <a class="indexterm" id="id501"/>collisions or optimize the current code. The <code class="literal">Collision.h</code> file contains a static method that checks for collisions between two <code class="literal">SDL_Rect</code> objects:</p><div class="informalexample"><pre class="programlisting">const static int s_buffer = 4;

static bool RectRect(SDL_Rect* A, SDL_Rect* B)
{
  int aHBuf = A-&gt;h / s_buffer;
  int aWBuf = A-&gt;w / s_buffer;

  int bHBuf = B-&gt;h / s_buffer;
  int bWBuf = B-&gt;w / s_buffer;

  // if the bottom of A is less than the top of B - no collision
  if((A-&gt;y + A-&gt;h) - aHBuf &lt;= B-&gt;y + bHBuf)  { return false; }

  // if the top of A is more than the bottom of B = no collision
  if(A-&gt;y + aHBuf &gt;= (B-&gt;y + B-&gt;h) - bHBuf)  { return false; }

  // if the right of A is less than the left of B - no collision
  if((A-&gt;x + A-&gt;w) - aWBuf &lt;= B-&gt;x +  bWBuf) { return false; }

  // if the left of A is more than the right of B - no collision
  if(A-&gt;x + aWBuf &gt;= (B-&gt;x + B-&gt;w) - bWBuf)  { return false; }

  // otherwise there has been a collision
 return true;
}</pre></div><p>The function makes use of a buffer, which is a value that is used to make the rectangles slightly smaller.<a class="indexterm" id="id502"/> In a game such as Alien Attack, exact collision on bounding rectangles would be slightly unfair and also not much fun. With the buffer value, more direct hits are needed before they will be registered as a collision. Here the buffer is set to <code class="literal">4</code>; this will take a fourth off of each side of the rectangle.</p><p>The <code class="literal">Player</code> class will not handle its own collisions. This requires a way to separate out the player from the rest of the <code class="literal">GameObject</code> instants when the level is loaded. The <code class="literal">Level</code> class now stores a pointer to <code class="literal">Player</code>:</p><div class="informalexample"><pre class="programlisting">Player* m_pPlayer;</pre></div><p>With a public getter and setter:</p><div class="informalexample"><pre class="programlisting">Player* getPlayer() { return m_pPlayer; }
void setPlayer(Player* pPlayer) { m_pPlayer = pPlayer; }</pre></div><p>The <code class="literal">LevelParser</code> instance sets this pointer when it loads in <code class="literal">Player</code> from the level file:</p><div class="informalexample"><pre class="programlisting">pGameObject-&gt;load(std::unique_ptr&lt;LoaderParams&gt;(new LoaderParams(x, y, width, height, textureID, numFrames,callbackID, animSpeed)));

if(type == "Player") // check if it's the player
{
  pLevel-&gt;setPlayer(dynamic_cast&lt;Player*&gt;(pGameObject));
}

pObjectLayer-&gt;getGameObjects()-&gt;push_back(pGameObject);</pre></div><p>Another addition to <code class="literal">Level</code> is that it holds a separate <code class="literal">std::vector</code> of <code class="literal">TileLayer*</code> which are tile layers that the game will <a class="indexterm" id="id503"/>check against for collisions. This value is passed in from the <code class="literal">.tmx</code> file and any <code class="literal">TileLayer</code> that needs to be checked for collisions must set <code class="literal">collidable</code> as a property in the tiled application.</p><div class="mediaobject"><img alt="Dealing with collisions" src="graphics/6821OT_08_07.jpg"/></div><p>This also requires a slight alteration in<a class="indexterm" id="id504"/> <code class="literal">LevelParser::parseLevel</code> when checking for object layers, just in case the layer does contain properties (in which case data would no longer be the first child element):</p><div class="informalexample"><pre class="programlisting">else if(e-&gt;FirstChildElement()-&gt;Value() == std::string("data") || (e-&gt;FirstChildElement()-&gt;NextSiblingElement() != 0 &amp;&amp; e-&gt;FirstChildElement()-&gt;NextSiblingElement()-&gt;Value() == std::string("data")))
{
  parseTileLayer(e, pLevel-&gt;getLayers(), pLevel-&gt;getTilesets(), 
  pLevel-&gt;getCollisionLayers());
}</pre></div><p>The <code class="literal">LevelParser</code> instance can now add collision layers to the collision layers array in <code class="literal">parseTileLayer</code>:</p><div class="informalexample"><pre class="programlisting">// local temporary variable
bool collidable = false;

// other code…

for(TiXmlElement* e = pTileElement-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == std::string("properties"))
  {
    for(TiXmlElement* property = e-&gt;FirstChildElement(); property != NULL; property = property-&gt;NextSiblingElement())
    {
      if(property-&gt;Value() == std::string("property"))
      {
        if(property-&gt;Attribute("name") == std::string("collidable"))
        {
          collidable = true;
        }
      }
    }
  }

  if(e-&gt;Value() == std::string("data"))
  {
    pDataNode = e;
  }
}

// other code…

// push into collision array if necessary
if(collidable)
{
  pCollisionLayers-&gt;push_back(pTileLayer);
}

pLayers-&gt;push_back(pTileLayer);</pre></div><div class="section" title="Creating a CollisionManager class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Creating a CollisionManager class</h2></div></div></div><p>The class<a class="indexterm" id="id505"/> responsible for checking<a class="indexterm" id="id506"/> and handling all of these collisions<a class="indexterm" id="id507"/> is the <code class="literal">CollisionManager</code> class. Here is its declaration:</p><div class="informalexample"><pre class="programlisting">class CollisionManager
{
public:

  void checkPlayerEnemyBulletCollision(Player* pPlayer);
  void checkPlayerEnemyCollision(Player* pPlayer, const 
  std::vector&lt;GameObject*&gt; &amp;objects);
  void checkEnemyPlayerBulletCollision(const 
  std::vector&lt;GameObject*&gt; &amp;objects);
  void checkPlayerTileCollision(Player* pPlayer, const 
  std::vector&lt;TileLayer*&gt; &amp;collisionLayers);
};</pre></div><p>Looking at the source<a class="indexterm" id="id508"/> code you will see that these functions are pretty big, yet they are relatively simple. They loop through each object that requires a collision test, create a rectangle for each,<a class="indexterm" id="id509"/> and then pass it to the static <code class="literal">RectRect</code> function defined in <code class="literal">Collision.h</code>. If a collision occurred then it calls the <code class="literal">collision</code> function for that object. The <code class="literal">checkEnemyPlayerBulletCollision</code>
<a class="indexterm" id="id510"/> and <a class="indexterm" id="id511"/>
<code class="literal">checkPlayerEnemyCollision</code> functions perform an extra check to see if the object is actually of <code class="literal">Enemy</code> type:</p><div class="informalexample"><pre class="programlisting">if(objects[i]-&gt;type() != std::string("Enemy") || !objects[i]-&gt;updating())
{
 continue;
}</pre></div><p>If it is not, then it does not check the collision. This is why it is important that the <code class="literal">Enemy</code> subtypes do not override the <a class="indexterm" id="id512"/>
<code class="literal">type</code> function or if they do, their type must also be added to this check. This condition also checks whether the object is updating or not; if it is not, then it is offscreen and does not need to be checked against for collision.</p><p>Checking for collision against tiles requires a similar method to working out where to start drawing the tiles from, which was implemented in the <code class="literal">TileLayer::render</code> function. Here is the <code class="literal">checkPlayerTileCollision</code> definition:</p><div class="informalexample"><pre class="programlisting">void CollisionManager::checkPlayerTileCollision(Player* pPlayer, 
  const std::vector&lt;TileLayer*&gt; &amp;collisionLayers)
{
  // iterate through collision layers
  for(std::vector&lt;TileLayer*&gt;::const_iterator it = 
  collisionLayers.begin(); it != collisionLayers.end(); ++it)
  {
    TileLayer* pTileLayer = (*it);
    std::vector&lt;std::vector&lt;int&gt;&gt; tiles = pTileLayer-
    &gt;getTileIDs();

    // get this layers position
    Vector2D layerPos = pTileLayer-&gt;getPosition();

    int x, y, tileColumn, tileRow, tileid = 0;

    // calculate position on tile map
    x = layerPos.getX() / pTileLayer-&gt;getTileSize();
    y = layerPos.getY() / pTileLayer-&gt;getTileSize();

    // if moving forward or upwards
    if(pPlayer-&gt;getVelocity().getX() &gt;= 0 || pPlayer-
    &gt;getVelocity().getY() &gt;= 0)
    {
      tileColumn = ((pPlayer-&gt;getPosition().getX() + pPlayer-
      &gt;getWidth()) / pTileLayer-&gt;getTileSize());
      tileRow = ((pPlayer-&gt;getPosition().getY() + pPlayer-
      &gt;getHeight()) 
      / pTileLayer-&gt;getTileSize());
      tileid = tiles[tileRow + y][tileColumn + x];
    }
    else if(pPlayer-&gt;getVelocity().getX() &lt; 0 || pPlayer-
    &gt;getVelocity().getY() &lt; 0) // if moving backwards or downwards
    {
      tileColumn = pPlayer-&gt;getPosition().getX() / pTileLayer-
      &gt;getTileSize();
      tileRow = pPlayer-&gt;getPosition().getY() / pTileLayer-
      &gt;getTileSize();
      tileid = tiles[tileRow + y][tileColumn + x];
    }
    if(tileid != 0) // if the tile id not blank then collide
    {
      pPlayer-&gt;collision();
    }
  }
}</pre></div></div></div></body></html>