<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parsing states from an XML file</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Parsing states from an XML file"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Parsing states from an XML file</h1></div></div></div><p>The file <a class="indexterm" id="id348"/>we will be <a class="indexterm" id="id349"/>parsing is the following (<code class="literal">test.xml</code> in source code downloads):</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" ?&gt;
&lt;STATES&gt;
&lt;MENU&gt;
&lt;TEXTURES&gt;
  &lt;texture filename="assets/button.png" ID="playbutton"/&gt;
  &lt;texture filename="assets/exit.png" ID="exitbutton"/&gt;
&lt;/TEXTURES&gt;

&lt;OBJECTS&gt;
  &lt;object type="MenuButton" x="100" y="100" width="400" 
  height="100" textureID="playbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="100" y="300" width="400" 
  height="100" textureID="exitbutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;
&lt;/MENU&gt;
&lt;PLAY&gt;
&lt;/PLAY&gt;

&lt;GAMEOVER&gt;
&lt;/GAMEOVER&gt;
&lt;/STATES&gt;</pre></div><p>We are going to create a new class that parses our states for us called <code class="literal">StateParser</code>. The <code class="literal">StateParser</code> class<a class="indexterm" id="id350"/> has no data members, it is to be used once in<a class="indexterm" id="id351"/> the <code class="literal">onEnter</code> function of a state and then discarded when it goes out of scope. Create a <code class="literal">StateParser.h</code> file and add the following code:</p><div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "tinyxml.h"

class GameObject;

class StateParser
{
  public:

  bool parseState(const char* stateFile, std::string stateID, 
  std::vector&lt;GameObject*&gt; *pObjects);

  private:

  void parseObjects(TiXmlElement* pStateRoot, 
  std::vector&lt;GameObject*&gt; *pObjects);
  void parseTextures(TiXmlElement* pStateRoot, 
  std::vector&lt;std::string&gt; *pTextureIDs);

};</pre></div><p>We have three functions here, one public and two private. The <code class="literal">parseState</code> function takes the filename of an XML file as a parameter, along with the current <code class="literal">stateID</code> value and a pointer to <code class="literal">std::vector</code> of <code class="literal">GameObject*</code> for that state. The <code class="literal">StateParser.cpp</code> file will define this function:</p><div class="informalexample"><pre class="programlisting">bool StateParser::parseState(const char *stateFile, string 
stateID, vector&lt;GameObject *&gt; *pObjects, std::vector&lt;std::string&gt; 
*pTextureIDs)
{
  // create the XML document
  TiXmlDocument xmlDoc;

  // load the state file
  if(!xmlDoc.LoadFile(stateFile))
  {
    cerr &lt;&lt; xmlDoc.ErrorDesc() &lt;&lt; "\n";
    return false;
  }

  // get the root element
  TiXmlElement* pRoot = xmlDoc.RootElement();

  // pre declare the states root node
  TiXmlElement* pStateRoot = 0;
  // get this states root node and assign it to pStateRoot
  for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = 
  e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == stateID)
    {
      pStateRoot = e;
    }
  }

  // pre declare the texture root
  TiXmlElement* pTextureRoot = 0;

  // get the root of the texture elements
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == string("TEXTURES"))
    {
      pTextureRoot = e;
    }
  }

  // now parse the textures
  parseTextures(pTextureRoot, pTextureIDs);

  // pre declare the object root node
  TiXmlElement* pObjectRoot = 0;

  // get the root node and assign it to pObjectRoot
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == string("OBJECTS"))
    {
      pObjectRoot = e;
    }
  }

  // now parse the objects
  parseObjects(pObjectRoot, pObjects);

  return true;
}</pre></div><p>There is a lot of code in this <a class="indexterm" id="id352"/>function so it is worth covering in some depth. We will note the corresponding part of the XML file, along with the code we use, to obtain it. The first part of the function attempts to load the XML file that is passed into<a class="indexterm" id="id353"/> the function:</p><div class="informalexample"><pre class="programlisting">// create the XML document
TiXmlDocument xmlDoc;

// load the state file
if(!xmlDoc.LoadFile(stateFile))
{
  cerr &lt;&lt; xmlDoc.ErrorDesc() &lt;&lt; "\n";
  return false;
}</pre></div><p>It displays an error to let you know what happened if the XML loading fails. Next we must grab the root node of the XML file:</p><div class="informalexample"><pre class="programlisting">// get the root element
TiXmlElement* pRoot = xmlDoc.RootElement(); // &lt;STATES&gt;</pre></div><p>The rest of the nodes in the file are all children of this root node. We must now get the root node of the state we are currently parsing; let's say we are looking for <code class="literal">MENU</code>:</p><div class="informalexample"><pre class="programlisting">// declare the states root node
TiXmlElement* pStateRoot = 0;
// get this states root node and assign it to pStateRoot
for(TiXmlElement* e = pRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == stateID)
  {
    pStateRoot = e;
  }
}</pre></div><p>This piece<a class="indexterm" id="id354"/> of code goes through each direct child of the root node and checks if its name is the same as <code class="literal">stateID</code>. Once it finds the correct node it assigns it to <code class="literal">pStateRoot</code>. We now have the root node of the state we want to parse.</p><div class="informalexample"><pre class="programlisting">&lt;MENU&gt; // the states root node</pre></div><p>Now that we<a class="indexterm" id="id355"/> have a pointer to the root node of our state we can start to grab values from it. First we want to load the textures from the file so we look for the <code class="literal">&lt;TEXTURE&gt;</code> node using the children of the <code class="literal">pStateRoot</code> object we found before:</p><div class="informalexample"><pre class="programlisting">// pre declare the texture root
TiXmlElement* pTextureRoot = 0;

// get the root of the texture elements
for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != NULL;
e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == string("TEXTURES"))
  {
    pTextureRoot = e;
  }
}</pre></div><p>Once the <code class="literal">&lt;TEXTURE&gt;</code> node is found, we can pass it into the private <code class="literal">parseTextures</code> function (which we will cover a little later).</p><div class="informalexample"><pre class="programlisting">parseTextures(pTextureRoot, std::vector&lt;std::string&gt; *pTextureIDs);</pre></div><p>The function then moves onto searching for the <code class="literal">&lt;OBJECT&gt;</code> node and, once found, it passes it into the private<a class="indexterm" id="id356"/> <code class="literal">parseObjects</code> function. We also pass in the <code class="literal">pObjects</code> parameter:</p><div class="informalexample"><pre class="programlisting">  // pre declare the object root node
  TiXmlElement* pObjectRoot = 0;

  // get the root node and assign it to pObjectRoot
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
  {
    if(e-&gt;Value() == string("OBJECTS"))
    {
      pObjectRoot = e;
    }
  }
  parseObjects(pObjectRoot, pObjects);
  return true;
}</pre></div><p>At this point<a class="indexterm" id="id357"/> our state has been parsed. We can now cover the two private functions, starting with <code class="literal">parseTextures</code>.</p><div class="informalexample"><pre class="programlisting">void StateParser::parseTextures(TiXmlElement* pStateRoot, std::vector&lt;std::string&gt; *pTextureIDs)
{
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    string filenameAttribute = e-&gt;Attribute("filename");
    string idAttribute = e-&gt;Attribute("ID");
    pTextureIDs-&gt;push_back(idAttribute); // push into list

    TheTextureManager::Instance()-&gt;load(filenameAttribute, 
    idAttribute, TheGame::Instance()-&gt;getRenderer());
  }
}</pre></div><p>This function gets the <code class="literal">filename</code> and <code class="literal">ID</code> attributes from each of the texture values in this part of the XML:</p><div class="informalexample"><pre class="programlisting">&lt;TEXTURES&gt;
  &lt;texture filename="button.png" ID="playbutton"/&gt;
  &lt;texture filename="exit.png" ID="exitbutton"/&gt;
&lt;/TEXTURES&gt;</pre></div><p>It then adds them to <code class="literal">TextureManager</code>.</p><div class="informalexample"><pre class="programlisting">TheTextureManager::Instance()-&gt;load(filenameAttribute, idAttribute, TheGame::Instance()-&gt;getRenderer());</pre></div><p>The <code class="literal">parseObjects</code> function<a class="indexterm" id="id358"/> is quite a bit more complicated. It creates objects<a class="indexterm" id="id359"/> using our <code class="literal">GameObjectFactory</code> function and reads from this part of the XML file:</p><div class="informalexample"><pre class="programlisting">&lt;OBJECTS&gt;
  &lt;object type="MenuButton" x="100" y="100" width="400" 
  height="100" textureID="playbutton" numFrames="0" 
  callbackID="1"/&gt;
  &lt;object type="MenuButton" x="100" y="300" width="400" 
  height="100" textureID="exitbutton" numFrames="0" 
  callbackID="2"/&gt;
&lt;/OBJECTS&gt;</pre></div><p>The <a class="indexterm" id="id360"/>
<code class="literal">parseObjects</code> function<a class="indexterm" id="id361"/> is defined like so:</p><div class="informalexample"><pre class="programlisting">void StateParser::parseObjects(TiXmlElement *pStateRoot, 
std::vector&lt;GameObject *&gt; *pObjects)
{
  for(TiXmlElement* e = pStateRoot-&gt;FirstChildElement(); e != 
  NULL; e = e-&gt;NextSiblingElement())
  {
    int x, y, width, height, numFrames, callbackID, animSpeed;
    string textureID;

    e-&gt;Attribute("x", &amp;x);
    e-&gt;Attribute("y", &amp;y);
    e-&gt;Attribute("width",&amp;width);
    e-&gt;Attribute("height", &amp;height);
    e-&gt;Attribute("numFrames", &amp;numFrames);
    e-&gt;Attribute("callbackID", &amp;callbackID);
    e-&gt;Attribute("animSpeed", &amp;animSpeed);

    textureID = e-&gt;Attribute("textureID");

    GameObject* pGameObject = TheGameObjectFactory::Instance()
    -&gt;create(e-&gt;Attribute("type"));
    pGameObject-&gt;load(new LoaderParams
    (x,y,width,height,textureID,numFrames,callbackID, animSpeed));
    pObjects-&gt;push_back(pGameObject);
  }
}</pre></div><p>First we get any values we need from the current node. Since XML files are pure text, we cannot simply grab<a class="indexterm" id="id362"/> ints or floats from the file. TinyXML has functions with which you can pass in the value you want to be set and the attribute name. For example:</p><div class="informalexample"><pre class="programlisting">e-&gt;Attribute("x", &amp;x);</pre></div><p>This sets the variable <code class="literal">x</code> to the value contained within attribute <code class="literal">"x"</code>. Next comes the creation of a <code class="literal">GameObject</code>
<span class="strong"><strong>*</strong></span> class using the factory.</p><div class="informalexample"><pre class="programlisting">GameObject* pGameObject = TheGameObjectFactory::Instance()-&gt;create(e-&gt;Attribute("type"));</pre></div><p>We pass in the value from the <code class="literal">type</code> attribute and use that to create the correct object from the factory. After this we must use the <code class="literal">load</code> function of <code class="literal">GameObject</code> to set our desired values using the values loaded from the XML file.</p><div class="informalexample"><pre class="programlisting">pGameObject-&gt;load(new LoaderParams(x,y,width,height,textureID,numFrames,callbackID));</pre></div><p>And finally we <a class="indexterm" id="id363"/>push <code class="literal">pGameObject</code> into the <code class="literal">pObjects</code> array, which is actually a pointer to the current state's object vector.</p><div class="informalexample"><pre class="programlisting">pObjects-&gt;push_back(pGameObject);</pre></div></div></body></html>