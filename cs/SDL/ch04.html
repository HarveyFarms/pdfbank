<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. Exploring Movement and Input Handling</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="chapter" title="Chapter 4. Exploring Movement and Input Handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Exploring Movement and Input Handling</h1></div></div></div><p>We have already covered drawing to the screen and how to handle objects but we have not had anything moving around very much yet. Getting input from the user and then controlling our game objects is one of the most important topics in game development. It can decide the feel and responsiveness of your game and is something that a user can really pick up on. In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cartesian coordinate systems</li><li class="listitem" style="list-style-type: disc">2D vectors</li><li class="listitem" style="list-style-type: disc">Creating variables to control the movement of a game object</li><li class="listitem" style="list-style-type: disc">Setting up a simple movement system</li><li class="listitem" style="list-style-type: disc">Setting up input handling from joysticks, keyboard, and mouse</li><li class="listitem" style="list-style-type: disc">Creating a fixed frame rate</li></ul></div><div class="section" title="Setting up game objects for movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Setting up game objects for movement</h1></div></div></div><p>In the previous chapter, <a class="indexterm" id="id188"/>we gave our objects x and y values which we could then use to pass into our drawing code. The x and y values we used can be represented using a Cartesian coordinate system.</p><div class="mediaobject"><img alt="Setting up game objects for movement" src="graphics/6821OT_04_01.jpg"/></div><p>The above figure shows a <a class="indexterm" id="id189"/>Cartesian coordinate system (flipped on the Y axis) with two coordinates. Representing them as (x,y) gives us position 1 as (3,3) and position 2 as (7,4). These values can be used to represent a position in 2D space. Imagine this figure as a zoomed in image of the top-left corner of our game window, with each of the grid squares representing one pixel of our game window. With this in mind, we can see how to use these values to draw things to the screen in the correct position. We now need a way to update these position values so that we can move our objects around. For this we will look at 2D vectors.</p><div class="section" title="What is a vector?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>What is a vector?</h2></div></div></div><p>A <span class="strong"><strong>vector</strong></span> can be<a class="indexterm" id="id190"/> described as an entity with a direction and a magnitude. We can use them<a class="indexterm" id="id191"/> to represent aspects of our game objects, for example, velocity and acceleration, that can be used to create movement. Taking velocity as an example,<a class="indexterm" id="id192"/> to fully represent<a class="indexterm" id="id193"/> the velocity of our objects, we need the direction in which they are travelling and also the amount (or magnitude) by which they are heading in that direction.</p><div class="mediaobject"><img alt="What is a vector?" src="graphics/6821OT_04_02.jpg"/></div><p>Let's define a couple of things about how we <a class="indexterm" id="id194"/>will use vectors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will represent a vector as v(x,y)<p>We can get the length of a vector using the following equation:</p><div class="mediaobject"><img alt="What is a vector?" src="graphics/6821OT_04_03.jpg"/></div></li></ul></div><p>The preceding figure shows the vector v1(3,-2) which will have a length of √(32+(-22)). We can use the x and y components of a vector to represent our object's position in 2D space. We can then use some common vector operations to move our objects. Before we move onto these operations let's create a vector class called <code class="literal">Vector2D</code> in the project. We can then look at each operation we will need and add them to the class.</p><div class="informalexample"><pre class="programlisting">#include&lt;math.h&gt;
class Vector2D
{
public:
  Vector2D(float x, float y): m_x(x), m_y(y) {}

  float getX() { return m_x; }
  float getY() { return m_y; }

  void setX(float x) { m_x = x; }
  void setY(float y) { m_y = y; }
private:

  float m_x;
  float m_y;
};</pre></div><p>You can see that the <code class="literal">Vector2D</code> class is very simple at this point. We have our x and y values and a <a class="indexterm" id="id195"/>way to get and set them. We already know how to get the length of a vector, so let's create a function for this purpose:</p><div class="informalexample"><pre class="programlisting">float length() { return sqrt(m_x * m_x + m_y * m_y); }</pre></div></div><div class="section" title="Some common operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Some common operations</h2></div></div></div><p>Now since we have our basic class in place, we can start to gradually add some operations.</p><div class="section" title="Addition of two vectors"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Addition of two vectors</h3></div></div></div><p>The first<a class="indexterm" id="id196"/> operation we will look at is the addition of two vectors. For this we simply add together the individual components of each vector.</p><div class="mediaobject"><img alt="Addition of two vectors" src="graphics/6821OT_04_04.jpg"/></div><p>Let's make use of overloaded operators to make it easy for us to add two vectors together:</p><div class="informalexample"><pre class="programlisting">Vector2D operator+(const Vector2D&amp; v2) const
{
  return Vector2D(m_x + v2.m_x, m_y + v2.m_y);
}

friend Vector2D&amp; operator+=(Vector2D&amp; v1, const Vector2D&amp; v2)
{
  v1.m_x += v2.m_x;
  v1.m_y += v2.m_y;

  return v1;
}</pre></div><p>With these <a class="indexterm" id="id197"/>functions we can add two vectors together using the standard addition operators, for example:</p><div class="informalexample"><pre class="programlisting">Vector2D v1(10, 11);
Vector2D v2(35,25);
v1 += v2;
Vector2D v3 = v1 + v2;</pre></div></div><div class="section" title="Multiply by a scalar number"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Multiply by a scalar number</h3></div></div></div><p>Another operation <a class="indexterm" id="id198"/>is to multiply a vector by a regular scalar number. For this operation we multiply each component of the vector by the scalar number:</p><div class="mediaobject"><img alt="Multiply by a scalar number" src="graphics/6821OT_04_05.jpg"/></div><p>We can again use overloaded operators to create these functions:</p><div class="informalexample"><pre class="programlisting">Vector2D operator*(float scalar)
{
  return Vector2D(m_x * scalar, m_y * scalar);
}

Vector2D&amp; operator*=(float scalar)
{
  m_x *= scalar;
  m_y *= scalar;

  return *this;
}</pre></div></div><div class="section" title="Subtraction of two vectors"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Subtraction of two vectors</h3></div></div></div><p>Subtraction is <a class="indexterm" id="id199"/>very similar to addition.</p><div class="mediaobject"><img alt="Subtraction of two vectors" src="graphics/6821OT_04_06.jpg"/></div><p>Let's create some functions to do this for us:</p><div class="informalexample"><pre class="programlisting">Vector2D operator-(const Vector2D&amp; v2) const
{ 
  return Vector2D(m_x - v2.m_x, m_y - v2.m_y); 
}

friend Vector2D&amp; operator-=(Vector2D&amp; v1, const Vector2D&amp; v2)
{
  v1.m_x -= v2.m_x;
  v1.m_y -= v2.m_y;

  return v1;
}</pre></div></div><div class="section" title="Divide by a scalar number"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Divide by a scalar number</h3></div></div></div><p>By now I am <a class="indexterm" id="id200"/>sure you have noticed a pattern emerging and can guess how dividing a vector by a scalar will work, but we will cover it anyway.</p><div class="mediaobject"><img alt="Divide by a scalar number" src="graphics/6821OT_04_07.jpg"/></div><p>And our functions:</p><div class="informalexample"><pre class="programlisting">Vector2D operator/(float scalar)    
{
  return Vector2D(m_x / scalar, m_y / scalar);
}

Vector2D&amp; operator/=(float scalar)
{
  m_x /= scalar;
  m_y /= scalar;

  return *this;
}</pre></div></div><div class="section" title="Normalizing a vector"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Normalizing a vector</h3></div></div></div><p>We need another<a class="indexterm" id="id201"/> very important operation and that is the ability to normalize a vector. Normalizing a vector makes its length equal to 1. Vectors with a length (magnitude) of 1 are known as unit vectors and are useful to represent just a direction, such as the facing direction of an object. To normalize a vector we multiply it by the inverse of its length.</p><div class="mediaobject"><img alt="Normalizing a vector" src="graphics/6821OT_04_08.jpg"/></div><p>We can create a new member function to normalize our vectors:</p><div class="informalexample"><pre class="programlisting">void normalize()
{
  float l = length();
  if ( l &gt; 0) // we never want to attempt to divide by 0
  {
    (*this) *= 1 / l;
  }
}
</pre></div><p>Now that we have a few basic functions in place, let's start to use these vectors in our <code class="literal">SDLGameObject</code> class.</p></div></div><div class="section" title="Adding the Vector2D class"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Adding the Vector2D class</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open<a class="indexterm" id="id202"/> up <code class="literal">SDLGameObject.h</code> and we can begin implementing the vectors. First we need to include the new <code class="literal">Vector2D</code> class.<div class="informalexample"><pre class="programlisting">#include "Vector2D.h"</pre></div></li><li class="listitem">We also need to remove the previous <code class="literal">m_x</code> and <code class="literal">m_y</code> values and replace them with <code class="literal">Vector2D</code>.<div class="informalexample"><pre class="programlisting">Vector2D m_position;</pre></div></li><li class="listitem">Now we can move to the <code class="literal">SDLGameObject.cpp</code> file and update the constructor.<div class="informalexample"><pre class="programlisting">SDLGameObject::SDLGameObject(const LoaderParams* pParams) : GameObject(pParams), m_position(pParams-&gt;getX(), pParams-&gt;getY())
{
  m_width = pParams-&gt;getWidth();
  m_height = pParams-&gt;getHeight();
  m_textureID = pParams-&gt;getTextureID();

  m_currentRow = 1;
  m_currentFrame = 1;
}</pre></div></li><li class="listitem">We <a class="indexterm" id="id203"/>now construct the <code class="literal">m_position</code> vector using the member initialization list and we must also use the <code class="literal">m_position</code> vector in our draw function.<div class="informalexample"><pre class="programlisting">void SDLGameObject::draw()
{
  TextureManager::Instance()-&gt;drawFrame(m_textureID, 
  (int)m_position.getX(), (int)m_position.getY(), m_width, 
  m_height, m_currentRow, m_currentFrame, 
  TheGame::Instance()-&gt;getRenderer());
}</pre></div></li><li class="listitem">One last thing before we test is to use our vector in the <code class="literal">Enemy::update</code> function.<div class="informalexample"><pre class="programlisting">void Enemy::update()
{
  m_position.setX(m_position.getX() + 1);
  m_position.setY(m_position.getY() + 1);
}</pre></div></li></ol></div><p>This function will use vector addition very soon, but for now we just add <code class="literal">1</code> to the current position to get the same behavior we already had. We can now run the game and we will see that we have implemented a very basic vector system. Go ahead and play around with the <code class="literal">Vector2D</code> functions.</p></div><div class="section" title="Adding velocity"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Adding velocity</h2></div></div></div><p>We previously had to <a class="indexterm" id="id204"/>separately set the <code class="literal">x</code> and <code class="literal">y</code> values of our objects, but now that our position is a vector, we have the ability to add a new vector to it to update our movement. We will call this vector the velocity vector and we can think of it as the amount we want our object to move in a specific direction:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The velocity vector can be represented as follows:<div class="mediaobject"><img alt="Adding velocity" src="graphics/6821OT_04_09.jpg"/></div></li><li class="listitem">We can add this to our <code class="literal">SDLGameObject</code> update function as this is the way we update all derived objects. So first let's create the velocity member variable.<div class="informalexample"><pre class="programlisting">Vector2D m_velocity;</pre></div></li><li class="listitem">We will construct it in the member initialization list as 0,0.<div class="informalexample"><pre class="programlisting">SDLGameObject::SDLGameObject(const LoaderParams* pParams) : GameObject(pParams), m_position(pParams-&gt;getX(), pParams-&gt;getY()), m_velocity(0,0)</pre></div></li><li class="listitem">And now we will move to the <code class="literal">SDLGameObject::update</code> function.<div class="informalexample"><pre class="programlisting">void SDLGameObject::update()
{
  m_position += m_velocity;
}</pre></div></li><li class="listitem">We can test this out in one of our derived classes. Move to <code class="literal">Player.cpp</code> and add the following:<div class="informalexample"><pre class="programlisting">void Player::update()
{
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));

  m_velocity.setX(1);

  SDLGameObject::update();
}</pre></div></li></ol></div><p>We set the <code class="literal">m_velocity</code> x value to 1. This means that we will add <code class="literal">1</code> to our <code class="literal">m_position</code> x value<a class="indexterm" id="id205"/> each time the update function is called. Now we can run this to see our object move using the new velocity vector.</p></div><div class="section" title="Adding acceleration"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Adding acceleration</h2></div></div></div><p>Not all of our objects <a class="indexterm" id="id206"/>will move along at a constant velocity. Some games will require that we gradually increase the velocity of our object using acceleration. A car or a spaceship are good examples. No one would expect these objects to hit their top speed instantaneously. We are going to need a new vector for acceleration, so let's add this into our <code class="literal">SDLGameObject.h</code> file.</p><div class="informalexample"><pre class="programlisting">Vector2D m_acceleration;</pre></div><p>Then we can add it to our <code class="literal">update</code> function.</p><div class="informalexample"><pre class="programlisting">void SDLGameObject::update()
{
  m_velocity += m_acceleration;
  m_position += m_velocity;
}</pre></div><p>Now alter our <code class="literal">Player::update</code> function to set the acceleration rather than the velocity.</p><div class="informalexample"><pre class="programlisting">void Player::update()
{
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));

  m_acceleration.setX(1);

  SDLGameObject::update();
}</pre></div><p>After running our game you will see that the object gradually picks up speed.</p></div></div></div></body></html>