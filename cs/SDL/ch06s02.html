<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Implementing Object Factories</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Implementing Object Factories"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Implementing Object Factories</h1></div></div></div><p>We are now armed with a little XML knowledge but before we move forward, we are going to take a look at Object Factories. <a class="indexterm" id="id338"/>An object factory is a class that is tasked with the creation of our objects. Essentially, we tell the factory the object we would like it to create and it goes ahead and creates a new instance of that object and then returns it. We can start by looking at a rudimentary implementation:</p><div class="informalexample"><pre class="programlisting">GameObject* GameObjectFactory::createGameObject(ID id)
{
  switch(id)
  {
    case "PLAYER":
      return new Player();
    break;
    
    case "ENEMY":
      return new Enemy();
    break;
    
    // lots more object types 
  }
}</pre></div><p>This function is very simple. We pass in an ID for the object and the factory uses a big switch statement to look it up and return the correct object. Not a terrible solution but also not a particularly good one, as the factory will need to know about each type it needs to create and maintaining the switch statement for many different objects would be extremely tedious. Just as when we covered looping through game objects in <a class="link" href="ch03.html" title="Chapter 3. Working with Game Objects">Chapter 3</a>, <span class="emphasis"><em>Working with Game Objects</em></span>, we want this factory not to care about which type we ask for. It shouldn't need to know all of the specific types we want it to create. Luckily this is something that we <a class="indexterm" id="id339"/>can definitely achieve.</p><div class="section" title="Using Distributed Factories"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Using Distributed Factories</h2></div></div></div><p>Through the use of Distributed Factories we can make a generic object factory that will create any of our types. <a class="indexterm" id="id340"/>Distributed factories allow us to dynamically maintain the types of objects we want our factory to create, rather than hard code them into a function (like in the preceding simple example). The approach we will take is to have the factory contain <code class="literal">std::map</code> that maps a string (the type of our object) to a small class called <code class="literal">Creator</code> whose only purpose is the creation of a specific object. We will register a new type with the factory using a function that takes a string (the ID) and a <code class="literal">Creator</code> class and adds them to the factory's map. We are going to start with the base class for all the <code class="literal">Creator</code> types. Create <code class="literal">GameObjectFactory.h</code> and declare this class at the top of the file.</p><div class="informalexample"><pre class="programlisting">#include &lt;string&gt;
#include &lt;map&gt;
#include "GameObject.h"

class BaseCreator
{
  public:

  virtual GameObject* createGameObject() const = 0;
  virtual ~BaseCreator() {}
};</pre></div><p>We can now go ahead and create the rest of our factory and then go through it piece by piece.</p><div class="informalexample"><pre class="programlisting">class GameObjectFactory
{
  public:

  bool registerType(std::string typeID, BaseCreator* pCreator)
  {
    std::map&lt;std::string, BaseCreator*&gt;::iterator it = 
    m_creators.find(typeID);

    // if the type is already registered, do nothing
    if(it != m_creators.end())
    {
      delete pCreator;
      return false;
    }

    m_creators[typeID] = pCreator;

    return true;
  }

  GameObject* create(std::string typeID)
  {
    std::map&lt;std::string, BaseCreator*&gt;::iterator it = 
    m_creators.find(typeID);

    if(it == m_creators.end())
    {
      std::cout &lt;&lt; "could not find type: " &lt;&lt; typeID &lt;&lt; "\n";
      return NULL;
    }

    BaseCreator* pCreator = (*it).second;
    return pCreator-&gt;createGameObject();
  }

  private:

  std::map&lt;std::string, BaseCreator*&gt; m_creators;

};</pre></div><p>This is quite<a class="indexterm" id="id341"/> a small class but it is actually very powerful. We will cover each part separately starting with <code class="literal">std::map m_creators</code>.</p><div class="informalexample"><pre class="programlisting">std::map&lt;std::string, BaseCreator*&gt; m_creators;</pre></div><p>This map holds the important elements of our factory, the functions of the class essentially either add or remove from this map. This becomes apparent when we look at the <code class="literal">registerType</code> function:<a class="indexterm" id="id342"/>
</p><div class="informalexample"><pre class="programlisting">bool registerType(std::string typeID, BaseCreator* pCreator)</pre></div><p>This function takes the ID we want to associate the object type with (as a string), and the creator object for that class. <a class="indexterm" id="id343"/>The function then attempts to find the type using the <code class="literal">std::mapfind</code> function:</p><div class="informalexample"><pre class="programlisting">std::map&lt;std::string, BaseCreator*&gt;::iterator it = m_creators.find(typeID);</pre></div><p>If the type is found then it is already registered. The function then deletes the passed in pointer and returns <code class="literal">false</code>:</p><div class="informalexample"><pre class="programlisting">if(it != m_creators.end())
{
  delete pCreator;
  return false;
}</pre></div><p>If the type is not already registered then it can be assigned to the map and then <code class="literal">true</code> is returned:</p><div class="informalexample"><pre class="programlisting">m_creators[typeID] = pCreator;
return true;
}</pre></div><p>As you can see, the <code class="literal">registerType</code> function is actually very simple; it is just a way to add types to the map. The <code class="literal">create</code> function is very similar:</p><div class="informalexample"><pre class="programlisting">GameObject* create(std::string typeID)
{
  std::map&lt;std::string, BaseCreator*&gt;::iterator it = 
  m_creators.find(typeID);

  if(it == m_creators.end())
  {
    std::cout &lt;&lt; "could not find type: " &lt;&lt; typeID &lt;&lt; "\n";
    return 0;
  }

  BaseCreator* pCreator = (*it).second;
  return pCreator-&gt;createGameObject();
}</pre></div><p>The function looks for the type in the same way as <code class="literal">registerType</code> does, but this time it checks whether the type was not found (as opposed to found). If the type is not found we return <code class="literal">0</code>, and if the type is found then we use the <code class="literal">Creator</code> object for that type to return a new instance of it as a pointer to <code class="literal">GameObject</code>.</p><p>It is worth noting that the <code class="literal">GameObjectFactory</code> class should probably be a singleton. We won't cover how to make it a singleton as this has been covered in the previous chapters. Try implementing <a class="indexterm" id="id344"/>it yourself or see how it is implemented in the source code download.</p></div></div></body></html>