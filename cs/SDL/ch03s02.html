<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Implementing polymorphism</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Implementing polymorphism"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec24"/>Implementing polymorphism</h1></div></div></div><p>This leads us to our next OOP feature, polymorphism. What polymorphism allows us to do is to refer to an object through a pointer to its parent or base class. This may not seem powerful at first, but <a class="indexterm" id="id165"/>what this will allow us to do is essentially have our <code class="literal">Game</code> class need only to store a list of pointers to one type and any derived types can also be added to <a class="indexterm" id="id166"/>this list. </p><p>Let us take our <code class="literal">GameObject</code> and <code class="literal">Player</code> classes as examples, with an added derived class, <code class="literal">Enemy</code>. In our <code class="literal">Game</code> class we have an array of <code class="literal">GameObject*</code>:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;GameObject*&gt; m_gameObjects;</pre></div><p>We then declare four new objects, all of which are <code class="literal">GameObject*</code>:</p><div class="informalexample"><pre class="programlisting">GameObject* m_player;
GameObject* m_enemy1;
GameObject* m_enemy2;
GameObject* m_enemy3;</pre></div><p>In our <code class="literal">Game::init</code> function we can then create instances of the objects using their individual types:</p><div class="informalexample"><pre class="programlisting">m_player = new Player();
m_enemy1 = new Enemy();
m_enemy2 = new Enemy();
m_enemy3 = new Enemy();</pre></div><p>Now they can be pushed into the array of <code class="literal">GameObject*</code>:</p><div class="informalexample"><pre class="programlisting">m_gameObjects.push_back(m_player);
m_gameObjects.push_back(m_enemy1);
m_gameObjects.push_back(m_enemy2);
m_gameObjects.push_back(m_enemy3);</pre></div><p>The <code class="literal">Game::draw</code> function can now look something like this:</p><div class="informalexample"><pre class="programlisting">void Game::draw()
{
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++) 
  {
    m_gameObjects[i]-&gt;draw(m_pRenderer);
  }
}</pre></div><p>Notice that we are looping through all of our objects and calling the <code class="literal">draw</code> function. The loop does not care that some of our objects are actually <code class="literal">Player</code> or <code class="literal">Enemy</code>; it handles them in the same manner.<a class="indexterm" id="id167"/> We are accessing them through a pointer to their base class. So, to add a new type, it simply needs to be derived from <code class="literal">GameObject</code>, and the <code class="literal">Game</code> class can handle it.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">So let's implement this for real in our framework. First we need a base class; we will stick with <code class="literal">GameObject</code>. We will have to make some changes to the class so that we can use it as a base class:<div class="informalexample"><pre class="programlisting">class GameObject
{
public:

  virtual void load(int x, int y, int width, int height, 
  std::string textureID);
  virtual void draw(SDL_Renderer* pRenderer);
  virtual void update();
  virtual void clean();

protected:

  std::string m_textureID;

  int m_currentFrame;
  int m_currentRow;

  int m_x;
  int m_y;

  int m_width;
  int m_height;
};</pre></div></li></ul></div><p>Notice that we have now prefixed our functions with the virtual keyword. The virtual keyword means that when calling this function through a pointer, it uses the definition from the type of the object itself, not the type of its pointer:</p><div class="informalexample"><pre class="programlisting">void Game::draw()
{
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++) 
  {
    m_gameObjects[i]-&gt;draw(m_pRenderer);  
  }
}</pre></div><p>In other words, this<a class="indexterm" id="id168"/> function would always call the <code class="literal">draw</code> function contained in <code class="literal">GameObject</code>, neither <code class="literal">Player</code> nor <code class="literal">Enemy</code>. We would never have the overridden behavior that we want. The virtual keyword would ensure that the <code class="literal">Player</code> and <code class="literal">Enemy</code> draw functions are called.</p><p>Now we have a base class, so let's go ahead and try it out in our <code class="literal">Game</code> class. We will start by declaring the objects in the <code class="literal">Game</code> header file:</p><div class="informalexample"><pre class="programlisting">GameObject* m_go;
GameObject* m_player;</pre></div><p>Now declare along with our <code class="literal">GameObject*</code> array:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;GameObject*&gt; m_gameObjects;</pre></div><p>Now create and load the objects in the <code class="literal">init</code> function, then push them into the array:</p><div class="informalexample"><pre class="programlisting">m_go = new GameObject();
m_player = new Player();

m_go-&gt;load(100, 100, 128, 82, "animate");
m_player-&gt;load(300, 300, 128, 82, "animate");

m_gameObjects.push_back(m_go);
m_gameObjects.push_back(m_player);</pre></div><p>So far, so good; we can now create a loop that will draw our objects and another that will update them. Now let's look at the <code class="literal">render</code> and <code class="literal">update</code> functions:</p><div class="informalexample"><pre class="programlisting">void Game::render()
{

  SDL_RenderClear(m_pRenderer); // clear to the draw colour

  // loop through our objects and draw them
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;draw(m_pRenderer);
  }

  SDL_RenderPresent(m_pRenderer); // draw to the screen

}

void Game::update()
{
  // loop through and update our objects
  for(std::vector&lt;GameObject*&gt;::size_type i = 0; i != 
  m_gameObjects.size(); i++)
  {
    m_gameObjects[i]-&gt;update();
  }
}</pre></div><p>As you can see,<a class="indexterm" id="id169"/> this is a lot tidier and also much easier to manage. Let us derive one more class from <code class="literal">GameObject</code> just so that we nail this concept down. Create a new class called <code class="literal">Enemy</code>:</p><div class="informalexample"><pre class="programlisting">class Enemy : public GameObject
{
public:

  void load(int x, int y, int width, int height, std::string 
  textureID);
  void draw(SDL_Renderer* pRenderer);
  void update();
  void clean();
};</pre></div><p>We will define the functions of this class the same as <code class="literal">Player</code> with only the <code class="literal">update</code> function as an exception:</p><div class="informalexample"><pre class="programlisting">void Enemy::update()
{
  m_y += 1;
  m_x += 1;
  m_currentFrame = int(((SDL_GetTicks() / 100) % 6));
}</pre></div><p>Now let's add it to the game. First, we declare it as follows:</p><div class="informalexample"><pre class="programlisting">GameObject* m_enemy;</pre></div><p>Then create, load, and add to the array:</p><div class="informalexample"><pre class="programlisting">m_enemy = new Enemy();
m_enemy-&gt;load(0, 0, 128, 82, "animate");
m_gameObjects.push_back(m_enemy);</pre></div><p>We have just <a class="indexterm" id="id170"/>added a new type and it was extremely quick and simple. Run the game to see our three objects, each with their own different behavior.</p><div class="mediaobject"><img alt="Implementing polymorphism" src="graphics/6821OT_03_02.jpg"/></div><p>We have covered a lot here and have a really nice system for handling our game objects, yet we still have an issue. <a class="indexterm" id="id171"/>There is nothing stopping us from deriving a class without the <code class="literal">update</code> or <code class="literal">draw</code> functions that we are using here, or even declaring a different function and putting the <code class="literal">update</code> code in there. It is unlikely that we, as the developers, would make this mistake, but others using the framework may. What we would like is the ability to force our derived classes to have their own implementation of a function we decide upon, creating something of a blueprint that we want all<a class="indexterm" id="id172"/> of our game objects to follow. We can achieve this through the use of an abstract base class.</p></div></body></html>