<?xml version="1.0" encoding="utf-8" standalone="no"?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Scrolling a tile map</title><link href="epub.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"/>
<meta name="Adept.resource" value="urn:uuid:db9d31f0-c605-45e5-bd7f-8555ec3e9527"/></head><body id="page"><div class="section" title="Scrolling a tile map"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Scrolling a tile map</h1></div></div></div><p>What we have created so far is fine for a game that takes place in one area that is the size of our window, but what about if we want to have large maps that are open to exploration. This is <a class="indexterm" id="id447"/>where scrolling comes into play. We have actually implemented this already but have not yet gone through it step-by-step or seen it in action. Let's do this now.</p><p>First of all, we must resize our map in the Tiled application. Navigating to <span class="strong"><strong>Map</strong></span> | <span class="strong"><strong>Resize Mapâ€¦</strong></span> will allow us to do this. Leave the height of our map at 15 and change the width to 60. Fill up the remaining squares with whatever tiles you like. The map would then look like the following screenshot:</p><div class="mediaobject"><img alt="Scrolling a tile map" src="graphics/6821OT_07_12.jpg"/></div><p>Save the map and we can look at the code:</p><div class="informalexample"><pre class="programlisting">int x, y, x2, y2 = 0;

x = m_position.getX() / m_tileSize;
y = m_position.getY() / m_tileSize;

x2 = int(m_position.getX()) % m_tileSize;
y2 = int(m_position.getY()) % m_tileSize;</pre></div><p>When scrolling the map we don't actually move it more than a tile width; we use the position value to work out where we should begin drawing our map from within the tile ID array. To get the <code class="literal">x</code> value we can use the position we have moved to divided by the tile width. For example, let's say that we have moved the map to <code class="literal">x position = 100</code> and the tile width is 32; this <a class="indexterm" id="id448"/>would give us a value of 3.125, but since we are using <code class="literal">int</code> values, this will simply be 3. We now know that we are to start drawing from the third tile across on the map. The <code class="literal">y</code> position works in the same way.</p><p>To ensure that our tile drawing does not jump between tiles, but smoothly scrolls, we use a modulo calculation to get the remaining tile amount that we need to move by and use that to position our map:</p><div class="informalexample"><pre class="programlisting">x2 = int(m_position.getX()) % m_tileSize;
y2 = int(m_position.getY()) % m_tileSize;</pre></div><p>We then subtract these values in the <code class="literal">draw</code> function:</p><div class="informalexample"><pre class="programlisting">(j * m_tileSize) - x2, (i * m_tileSize) - y2</pre></div><p>We can test this by setting a velocity in our layers <code class="literal">update</code> function:</p><div class="informalexample"><pre class="programlisting">void TileLayer::update()
{
  m_position += m_velocity;
  m_velocity.setX(1);
}</pre></div><p>And then in <code class="literal">PlayState</code> we can call this function:</p><div class="informalexample"><pre class="programlisting">void PlayState::update()
{
  pLevel-&gt;update();
}</pre></div><p>Run the game and you will see the map scrolling. At the moment we have not put any kind of handling in for<a class="indexterm" id="id449"/> looping the map or stopping at the end. We will cover this when we begin to create a game in later chapters.</p></div></body></html>